[{"content":"前言 元件(Componet) 是 Blazor 應用程式的基礎，是 UI 的元素，例如頁面、按鈕或者是表單，正式名稱為 Razor 元件(Razor component)\nRazor 是一種結合了 HTML 標記語言 與 C# 程式碼的語法\n內建在 .NET 組件中且具有下列功能的 .NET C# 類別：\n處理邏輯來啟用動態行為 可以為巢狀結構，且可重複使用 能以 Razor 類別庫或 NuGet 套件方式共用及散發 元件是由 C# 和 HTML 標記組合，檔案的副檔名為 .razor\n命名 需要以大寫的字母開頭 正確的命名 SampleComponet.razor\n錯誤的命名(編譯無法通過) sampleComponet.razor\n檔案名稱即是元件的名稱 再次以 SampleComponet.razor 為例，此時的元件名稱就會是SampleComponet\n看看 Counter 元件 在 Counter 文件中，我按照內容劃分了四個區塊\n@page 這個指示詞在Blazor中編譯時，會用做提供路由，以 @page \u0026quot;/counter\u0026quot;為例，我們可以透過 http://localhost:5001/counter 這個Url來呼叫Counter元件 更加詳細的路由說明，會在之後的文章為大家講解\nPageTitle 這邊載入 PageTitle 元件，看到這邊可能會有個疑惑\n他是誰? 他在哪? 他從哪裡來?\n為什麼專案沒有看到 PageTitle.razor 檔案卻可以被載入呢? 原因是他是微軟預先定義好的元件放置於 Microsoft.AspNetCore.Components.Web 這個Namespace中，聰明如你一定馬上衍伸另一個問題\n我也沒有 using 呀\n在專案內有個 _Imports.razor 內部會負責引用命名空間，放在其檔案內部的都會被所有元件載入 Razor 語法 這部分是Razor的語法，@currentCount會直接帶入對應的 C# 變數值 @onclick 則是對應 Razor @on{DOM EVENT}=\u0026quot;{DELEGATE}\u0026quot; 對點擊事件做處理 關於Blazor 的事件處理，也會在之後的文章為大家講解\n@code 區塊 在這邊撰寫 C# 邏輯程式碼 Razor 標記 和 C# 程式碼位於相同的檔案中，是元件撰寫中最常見的方法。\n實作表單元件 看到這邊大家應該都會了吧? 我們實作一個鐵人賽的報名頁面\n首先到方案總管內的Pages資料夾，右鍵-\u0026gt;加入-\u0026gt;Razor元件 對元件進行命名， 這邊我將元件取名為 IthomeIronMan.razor 加入 @Page 讓元件可以被呼叫 1 2 3 4 5 6 7 @page \u0026#34;/IthomeIronMan\u0026#34; \u0026lt;h3\u0026gt;IthomeIronMan\u0026lt;/h3\u0026gt; @code { } 做完後可以就可以把專案跑起來，網址輸入剛剛在Page後面加的 /IthomeIronMan 就可以看見剛剛新建立的元件\n接下來補上一點點細節 元件內部使用的語法是 Razor 語法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @page \u0026#34;/IthomeIronMan\u0026#34; @using System.ComponentModel.DataAnnotations \u0026lt;h3\u0026gt;主題競賽報名\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;請選擇組別，並填寫參賽題目及簡介。\u0026lt;/p\u0026gt; \u0026lt;EditForm Model=\u0026#34;@ironmanApplyModel\u0026#34; OnValidSubmit=\u0026#34;@HandleSubmit\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-title\u0026#34; for=\u0026#34;exampleFormControlSelect1\u0026#34;\u0026gt;選擇主題\u0026lt;/label\u0026gt;\u0026lt;label class=\u0026#34;note\u0026#34;\u0026gt;報名後無法修改\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;form-group \u0026#34;\u0026gt; \u0026lt;InputSelect @bind-Value=\u0026#34;ironmanApplyModel.Group\u0026#34; class=\u0026#34;form-control input-lg\u0026#34; required=\u0026#34;required\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34; disabled selected=\u0026#34;selected\u0026#34;\u0026gt;請選擇您要參加的競賽主題\u0026lt;/option\u0026gt; @foreach (var item in group) { \u0026lt;option value=\u0026#34;@item\u0026#34;\u0026gt;@item\u0026lt;/option\u0026gt; } \u0026lt;/InputSelect\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-title\u0026#34; for=\u0026#34;topic\u0026#34;\u0026gt;參賽題目\u0026lt;/label\u0026gt; \u0026lt;label class=\u0026#34;note\u0026#34;\u0026gt;開賽前可以修改，80個字以內\u0026lt;/label\u0026gt; \u0026lt;InputText id=\u0026#34;agenda\u0026#34; @bind-Value=\u0026#34;ironmanApplyModel.Topic\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;80 個字以內\u0026#34; required=\u0026#34;required\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-title\u0026#34; for=\u0026#34;intro\u0026#34;\u0026gt;題目簡介\u0026lt;/label\u0026gt; \u0026lt;label class=\u0026#34;note\u0026#34;\u0026gt;簡單介紹參賽的內容與方向，300個字以內\u0026lt;/label\u0026gt; \u0026lt;InputTextArea @bind-Value=\u0026#34;ironmanApplyModel.Description\u0026#34; class=\u0026#34;form-control input-lg\u0026#34; cols=\u0026#34;30\u0026#34; rows=\u0026#34;10\u0026#34; maxlength=\u0026#34;300\u0026#34; required=\u0026#34;required\u0026#34;\u0026gt;\u0026lt;/InputTextArea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group form-check\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; class=\u0026#34;form-check-input\u0026#34; id=\u0026#34;done\u0026#34; required=\u0026#34;required\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34; for=\u0026#34;done\u0026#34;\u0026gt;我已閱讀並同意受本\u0026lt;a href=\u0026#34;https://r.itho.me/ironguide\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;活動簡章\u0026lt;/a\u0026gt;及相關辦法規定之拘束。\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary btn-lg btn-block\u0026#34;\u0026gt;確定報名\u0026lt;/button\u0026gt; \u0026lt;/EditForm\u0026gt; @code { private List\u0026lt;string\u0026gt; group = new List\u0026lt;string\u0026gt; { \u0026#34;Agile\u0026#34;,\u0026#34;AI\u0026amp;Data\u0026#34;,\u0026#34;DevOps\u0026#34;,\u0026#34;IT管理\u0026#34;,\u0026#34;Mobile Development\u0026#34;, \u0026#34;Modern Web\u0026#34;,\u0026#34;Security\u0026#34;,\u0026#34;Software Development\u0026#34;,\u0026#34;Web 3\u0026#34;,\u0026#34;影片教學\u0026#34; }; private IronmanApplyModel ironmanApplyModel = new IronmanApplyModel(); private void HandleSubmit() { Console.WriteLine($\u0026#34;送出成功! 主題:{ironmanApplyModel.Group} 題目:{ironmanApplyModel.Topic} 說明:{ironmanApplyModel.Description}\u0026#34;); } public class IronmanApplyModel { [Required] public string Group { get; set; } [Required] [StringLength(80)] public string Topic { get; set; } [Required] [StringLength(300)] public string Description { get; set; } } } 填寫完成後送出可以在 Console 內看見送出的內容 將元件加入側邊選單 目前我們的元件有了 @page 指示詞 可以透過Url存取但是沒辦法透過UI的方式進入，最後我們將頁面放到選單中就完成這一個 Lab 了\n在 Shard 資料夾內找到 NavMenu.razor 檔案 在檔案內加入 Navlink 元件 1 2 3 4 5 \u0026lt;div class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;IthomeIronman\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-list-rich\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 報名鐵人賽 \u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; 小結 在這一個章節中我們了解了元件的命名規則、建立了一個元件、體驗了用C#來撰寫前端邏輯並且將元件與UI相結合。\n下一個章節會介紹元件的資料繫結(Data Binding)\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-004-componet-overview/","summary":"前言 元件(Componet) 是 Blazor 應用程式的基礎，是 UI 的元素，例如頁面、按鈕或者是表單，正式名稱為 Razor 元件(Razor component) Razor 是一種結合了 HTML 標記語言","title":"ASP.NET Core Blazor 系列 - 004 元件(Componet) 概觀"},{"content":"前言 在這一章會介紹 Blazor WebAssembly，分別是獨立(Standalone) Blazor WebAssembly和裝載(Hosted) Blazor WebAssembly 兩種範本專案。\n環境 Windows 11 Visual Studio 2022 .NET 6.0 Blazor WebAssembly (Standalone) 專案建立與執行 首先開啟 Visual Studio 2022，找到 Blazor WebAssembly 應用程式 在設定完專案名稱和路徑後，在其他資訊的選單可以做選擇是否要裝載在 ASP.NET Core 上(Hosted)，以及是否在啟用PWA的支援 專案建立完成後也是一樣點擊最上方長得像播放按鈕的開始偵錯，讓專案跑起來 建置完成就會又看見熟悉的 Hello World! 但是仔細看會發現一個不一樣的地方 Loading 會發現最一開始比起 Blazor Server 多了 Loading 頁面 Home Counter FetchData 其餘的頁面皆相同\n專案結構(Standalone) 接下來我們將目光移到VS內的方案總管\nBlazor Server 的部分已經分享過了，這次依照兩者的相異之處說明\n1. wwwroot 異動 原有的根頁面 從 _Host.cshtml 被 index.html取代 元件轉譯的位置在\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;的位置 2. Data 移除 原有的邏輯寫入頁面內部 3. Pages 異動 _Host.cshtml 被index.html取代移除 _Layout.cshtml 因為沒有了_Host.cshtml故也不存在，head 內容也轉移至 index.html 4. Properties 特別說明 在launchSettings.json檔案內，會多一行 inspectUrl 屬性，這個屬性的功能有以下兩個 1.讓 IDE 偵測應用程式是否為 Blazor WebAssembly 應用程式 2.指示腳本偵錯基礎結構透過 Blazor 的偵錯 Proxy 連線到瀏覽器 6. Other 剩下的是沒有在資料夾內的檔案\nappsetting.json 此檔案不再wasm範本中 Program.cs 設定 WebAssembly 主機的應用程式進入點，可以設定根元件以及要渲染的標籤 Blazor WebAssembly (Hosted) 專案 專案建立與執行 步驟大致上相同，只需在建立專案時，額外勾選裝載在ASP.NET Core上即可 在方案總管中會有兩個 Web 的專案，請啟動 Server 的專案，Client不需要啟動 當初我以為要啟動兩個專案，在設定啟動專案的視窗把兩個Web專案都勾選啟動 這樣做會看到 Socket Exception 告訴你Port被佔用了 專案結構(Hosted) 預設的專案範本有建立了三個專案，Client、Server、Shared\n1. Client 與上面的 Standalone 差不多，在 FetchData 元件內部有稍微不同\nStandalone FetchData.razor 1 2 3 4 protected override async Task OnInitializedAsync() { forecasts = await Http.GetFromJsonAsync\u0026lt;WeatherForecast[]\u0026gt;(\u0026#34;sample-data/weather.json\u0026#34;); } Hosted FetchData.razor 1 2 3 4 protected override async Task OnInitializedAsync() { forecasts = await Http.GetFromJsonAsync\u0026lt;WeatherForecast[]\u0026gt;(\u0026#34;WeatherForecast\u0026#34;); } GetFromJsonAsync 的方法參數不同\n2. Server 看是一個 ASP.NET Core 的 Web 專案\n專案內沒有 wwwroot 資料夾 Program.cs 的內容稍微與平常看到的不一樣 1 2 app.UseBlazorFrameworkFiles(); app.MapFallbackToFile(\u0026#34;index.html\u0026#34;); 3. Shared 是用來存放共用類別的地方\n運作方式 Blazor WebAssembly 是透過 WebAssembly 在瀏覽器端執行 .NET 程式碼，在網頁開啟時將會載入相關的 .NET 組件，其中包含相對應的 RunTime\n在Console中看見負責處理的檔案是blazor.webassembly.js\nBlazor Server，UI需要透過SignalR來與伺服端通訊和更新，在Blazor WebAssembly則不需要，所以比較不會有延遲的問題產生\n小結 Blazor Webassembly 本質上是一系列的檔案以及Javascript檔案，所以只要檔案可以正確地被載入並且瀏覽器支援WebAssembly，網頁就可以運作，所以 Blazor WebAssembly App 不必是 ASP.NET Core 網站，他可以是純HTML，甚至透過CDN來部署\n這邊總結一下我認為什麼時候選擇 獨立(Standalone) 什麼時候選擇 裝載(Hosted)\n若是你在開發Blazor WebAssembly App 的同時，使用 ASP.NET Core 撰寫後端，則可以使用同一個網站來做部署，這種情況可以直接使用裝載(Hosted)進行開發 ；如果你已有現有的第三方API或是 .NET Framework 既有的 Web API，可以直接使用獨立(Standalone) Blazor WebAssembly 開發\nBlazer WebAssembly 可以開發成完全不需要外部服務的應用程式，但可能為了安全性會想額外寫一個外部應用程式開放API，用來讀取資料庫、進行使用者驗證等等行為。\n專案範本的裝載(Hosted) 在 ASP.NET Core 上是指透過 ASP.NET Core 來開發外部應用程式(念起來很繞口)\n優點 載入完成後可以離線使用 運算負載會轉移到客戶端 缺點 瀏覽器需要支援 WebAssembly，需注意瀏覽器 載入時間會依應用程式複雜度增加而增加 ","permalink":"https://twjimwang.github.io/posts/programming/blazor-003-blazorwebassembly-projectstructure/","summary":"前言 在這一章會介紹 Blazor WebAssembly，分別是獨立(Standalone) Blazor WebAssembly和裝載(Hosted) Blazor WebAssembly 兩種範本專案","title":"ASP.NET Core Blazor 系列 - 003 專案架構(Blazor WebAssembly)"},{"content":"前言 在接下來的章節將會對兩種 Bloazr 的專案範本做解說，分別是 Blazor Server 以及 Blazor WebAssembly，其中 WebAssembly 會介紹獨立(Standalone) Blazor WebAssembly 和裝載(Hosted) Blazor WebAssembly。\n環境 Windows 11 Visual Studio 2022 .NET 6.0 Blazor Server 專案建立 首先開啟 Visual Studio 2022，找到 Blazor Server 應用程式 專案建立完成後點擊最上方長得像播放按鈕的開始偵錯，就可以進行編譯讓專案跑起來 在 .Net 6 預設是使用 Kestrel 啟動，而不是過去的 IIS\n建置完成就會看見熟悉的 Hello World! Home Counter FetchData 專案結構 接下來我們將目光移到VS內的方案總管\n這邊分成五大區塊來做說明\n1. Properties 在這個資料夾內有 LaunchSettings.json 檔案，用來提供VS執行應用程式時所要套用的組態設定 2. wwwroot 用來放靜態資產檔案的資料夾 3. Data 可以看見內部有兩個檔案\nWeatherForecast.cs 提供FetchData元件的資料類別 1 2 3 4 5 6 7 8 9 10 public class WeatherForecast { public DateTime Date { get; set; } public int TemperatureC { get; set; } public int TemperatureF =\u0026gt; 32 + (int)(TemperatureC / 0.5556); public string? Summary { get; set; } } WeatherForecastService.cs 提供FetchData元件Fetch資料的實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class WeatherForecastService { private static readonly string[] Summaries = new[] { \u0026#34;Freezing\u0026#34;, \u0026#34;Bracing\u0026#34;, \u0026#34;Chilly\u0026#34;, \u0026#34;Cool\u0026#34;, \u0026#34;Mild\u0026#34;, \u0026#34;Warm\u0026#34;, \u0026#34;Balmy\u0026#34;, \u0026#34;Hot\u0026#34;, \u0026#34;Sweltering\u0026#34;, \u0026#34;Scorching\u0026#34; }; public Task\u0026lt;WeatherForecast[]\u0026gt; GetForecastAsync(DateTime startDate) { return Task.FromResult(Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = startDate.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }).ToArray()); } } } 4. Pages 用來放置可供路由的元件或頁面(.razor)\n_Host.cshtml 是Blazor的根頁面(Root Page)，App 元件會解析在這邊 _Layout.cshtml 是 _Host.cshtml 的版面配置頁，Blazor Server 的 head 內容此檔案內 Counter 元件，實作計數器頁面 Error 元件，實作例外頁面 FetchData 元件，實作資料擷取頁 Index 元件，實作首頁 5. Shard 放置共用元件和樣式\nMainLayout 元件，應用程式的版面配置元件 NavMenu 元件，Navbar的樣式表單 SurveyPrompt 元件，問卷元件 6. Other 剩下的是沒有在資料夾內的檔案\n_Imports 元件，內部會放要放入元件內的指示詞，像是 @using App 元件，應用程式的根元件 appsetting.json 專案的設定檔 Program.cs .net Core 應用程式的進入點，在這邊做DI註冊、Middleware的處理等等 運作方式 Blazor Server 是依靠 SignalR 機制讓伺服端與客戶端進行雙向溝通，在瀏覽器開啟 Blazor 網頁時，客戶端會自動與伺服端建立SignalR連線。\n在Console中看見負責處理SignalR的檔案是blazor.server.js\n雙方透過每隔一段時間就會透過心跳包(Heartbeat)機制確保連線\n當我切換到Counter頁面，並且點擊Click Me按鈕觸發 UI 更新時，會重新轉譯元件圖形，計算UI Diff(差異) 後以二進位的方式傳送至瀏覽器套用進行畫面的更新\n透過SignalR的連線處理 JavaScript Interop 呼叫\n從 JavaScript 呼叫 .NET(BeginInvokeDotNetFromJs) 發送事件到伺服端 從 .NET 呼叫 JavaScript (JS.RenderBatch) 伺服端回應進行畫面渲染 從 JavaScript 呼叫 .NET(OnRenderCompleted) 通知伺服端畫面渲染完成 從 .NET 呼叫 JavaScript (JS.EndInvokeDotNet) 完成非同步呼叫 關於 JavaScript Interop 我以後也會專門寫文章跟大家探討XD\n小結 理解了 Blazor Server 運作的原理後，可以總結出幾項優缺點\n優點 載入的速度快 程式碼不會被傳送到Client端，安全性較佳 瀏覽器的支援性較佳 完整的 .NET API 缺點 所有的UI互動都通過與伺服器交互，可能會導致延遲感較明顯 無法使用無伺服器(Serverless)部署 伺服器的記憶體在高負載時可能會是最早耗盡的，一個SignalR線路大概使用250KB的記憶體 根據微軟提供的基準，如果要提供5000名使用者，記憶體至少需要預留1.3GB以上\n下一篇文章介紹 Blazor WebAssembly 的專案建置\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-002-blazorserver-projectstructure/","summary":"前言 在接下來的章節將會對兩種 Bloazr 的專案範本做解說，分別是 Blazor Server 以及 Blazor WebAssembly，其中 WebAssembly 會介紹獨立(Standalone) Blazor WebAssembly 和裝載(","title":"ASP.NET Core Blazor 系列 - 002 專案架構(Blazor Server)"},{"content":"前言 這個系列是記錄我學習 Blazor 的筆記，如果有任何錯誤的地方歡迎提出指教\nBlazor 是微軟打造的新一代全端解決方案，其名稱來自 Browser + Razor 可以讓網頁程式開發拋開 JavaScript 擁抱 C# 享受 .Net 所有的好處\n強型別 使用 C# 取代 Javascript 可以利用 .NET 現有的程式庫 Razor? Blazor? 首先先來整理一些概念，Razor 本身是一個將 .NET 程式碼內嵌到網頁的一種標記語法。\n在 Visual Studio 內建的專案範本，ASP.NET Core MVC 以及 ASP.NET Core Razor Page，在這兩種範本中都會出現Razor的字眼，Razor View 以及 Razor Page，這兩種範本是以 Razor 標記語言 為基底打造的頁面，檔案的副檔名是 .cshtml，其內部使用的語言都是 Razor 標記語言，而Blazor與上述Razor View 和Razor Page 類似屬於一種專案範本，檔案內使用的語言也是 Razor 標記語言，檔案的副檔名是 .razor\n既然 Razor View、Razor Page 以及 Blazor 都是用 Razor 撰寫那他們的差異在哪裡呢?\n最大的不同在於他們轉譯的行為，在 Razor View 以及 Razor Page 時，每一行的Razor程式碼都會被翻譯成HTML送到瀏覽器呈現，轉譯完成後就會執行 Dispose 清除該頁面或者檢視的執行個體以及他們的狀態，當另一個請求發起的時候在重新轉譯並且發送至客戶端，可以理解成每一次的 Request 都會取得全新的頁面。\nBlazor 的做法則是會先產生元件圖形(graph of components)，顯示類似於 HTML 或 XML 文件物件模型 (DOM)。Blazor 在透過元件圖形生成二進位表示法，在客戶端進行轉譯，每一個元件都是獨立的如果有變更就渲染對應的元件即可。\n簡單來說 Razor Page、Razor View 每一個請求都要整個頁面重新載入，而Blazor則可以做到類似JS操作DOM的效果\nBlazor 專案類型 Blazor 有兩種模式可以選擇，一個是 Blazor Server 另一個是 Blazor WebAssembly\nBlazor Server 過去我們在做傳統的網頁時，若希望用MVC做的頁面不會換頁時，會採用 Ajax 的方式來處理，透過WebAPI 取得資料後再利用JS更新畫面UI\nBlazor Server 的做法有異曲同工之妙，將原本的 Ajax 與 WebAPI 的這一段改成 SignalR 來處理， 透過 SignalR 來實作雙向的溝通更新UI。\n在伺服端上處理項目\n執行應用程式的 C# 將瀏覽器的UI 事件傳送到Server 將 UI 更新套用至已轉譯的元件，該元件會由伺服器傳回 在用戶端上，會由 blazor.server.js 建立與伺服器的SignalR連線\n優點 相較於Blazor WebAssembly體積更小載入更快 可以使用完整的伺服器資源 可以套用 .NET 工具，例如偵錯 支援度較高，可在不支援 WebAssembly 和資源限制裝置上的瀏覽器使用 應用程式的程式碼基底不會提供給客戶端 缺點 延遲可能會比較高，因為互動都要透過SignalR傳輸 無法離線使用 使用者人數多的時候需要較多伺服器資源 需要伺服器才能提供應用程式 Blazor WebAssembly Blazor Wasm 的做法更是新穎，透過 WebAssembly (wasm) 直接在瀏覽器執行 .Net 程式碼， 將 .Net RunTime 與 Code 一併打包發送到客戶端執行。\n在客戶端執行的項目\nC# 以及 Razor 被編譯成 .Net 組件 組件以及RunTime被下載到客戶端中 Blazor WebAssembly 啟動 .NET 執行階段，載入應用程式的組件。會使用 JavaScript Interop 來處理 DOM 操作和瀏覽器 API 呼叫 Blazor WebAssembly建立應用程式來部署時，不需要後端 ASP.NET Core應用程式來提供其檔案，則應用程式稱為 獨立(standalone) Blazor WebAssembly 應用程式。\n建立應用程式以使用後端應用程式來提供其檔案的部署時，應用程式稱為 裝載(Hosted) Blazor WebAssembly 的應用程式，會獲得 .NET 的完整堆疊 Web 開發體驗，包括能夠共用用戶端與伺服器應用程式之間的程式碼、支援預先呈現，以及與 MVC 和 Razor Pages 整合。\n在其用戶端應用程式可以使用各種傳訊架構和通訊協定，透過網路與其後端伺服器應用程式互動，例如Web API、gRPC-Web和 SignalR\n以上兩種部屬的模式，皆可以建置為漸進式 Web 應用程式的應用程式 (PWA)，使用新式瀏覽器 API 來啟用原生用戶端應用程式的許多功能，例如離線、在自己的應用程式視窗中執行、從主機的作業系統啟動、接收推播通知，以及在背景自動更新。\nblazor.webassembly.js 是由架構提供，並處理\n下載 .NET Runtime、應用程式和相依性 初始化Runtime 以執行 App 優點 如果伺服器離線，應用程式仍會運作，因為整個 RunTime 都在客戶端 完全運用用戶端資源和功能 運算會從伺服器轉移至用戶端處理 伺服器不需要裝載應用程式。透過內容傳遞網路提供應用程式 (CDN) 可以實現無伺服器的部屬 缺點 應用程式僅限於瀏覽器的功能 需要用戶端硬體和軟體支援，例如 WebAssembly 下載大小較大，而且應用程式需要較長的時間才能載入 如果發布的應用程式大太會導致下載時間較長，會導致使用者體驗不佳。 在這個問題上 Blazor WebAssembly 有幾套機制對大小進行最佳化，以縮短下載時間\n小結 Blazor Server 和 Blazor WebAssembly有各自的優缺點，在評估專案使用的技術時須依照需求進行考量，例如是否會需要完整的 .Net API 、是否需要將運算負載轉移到客戶端、是否需要離線時網頁依然可以保持運作等等，選擇最適合你的 Blazor 運作模式。\n下一篇文章將會介紹 Blazor Server 專案架構\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-001-overview/","summary":"前言 這個系列是記錄我學習 Blazor 的筆記，如果有任何錯誤的地方歡迎提出指教 Blazor 是微軟打造的新一代全端解決方案，其名稱來自 Browser + Razor 可以讓網頁程式開發拋開 JavaScript","title":"ASP.NET Core Blazor 系列 - 001 初次見面"}]