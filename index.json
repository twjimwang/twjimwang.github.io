[{"content":"前言 上一章我們介紹了 JWT 的基本原理，接下來我們會建立一個 WebAPI 並透過他發行 JWT Token，然後將導入 Token 驗證的機制\n建立 WebAssembly 專案 開啟 Visual Studio 點選建立新專案並點選 Blazor WebAssembly 勾選 裝載在 ASP.NET Core 上 完成專案建立\n發行 Token 完成專案的建置後，我們要在網頁的後端做 JWT\n安裝 NuGet 套件到 Blazor.Jwt.Server 專案內 1 dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer 在 Blazor.Jwt.Server 專案內，加入一個 API Controller 這邊我取名為 AuthorizeController.cs 修改Route Attribute\n1 [Route(\u0026#34;api/[controller]/[action]\u0026#34;)] 寫一個 GetToken 方法 這邊為了示範所以將邏輯都放在 Controller 內\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [HttpGet] public IActionResult GetToken(string userName) { var key = \u0026#34;2022/09/28 IThome 鐵人賽\u0026#34;; var claims = new List\u0026lt;Claim\u0026gt; { // 使用者名稱 new (JwtRegisteredClaimNames.Sub,userName), // Token Id new (JwtRegisteredClaimNames.Jti,Guid.NewGuid().ToString()) }; var claimsIdentity = new ClaimsIdentity(claims); var securityKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(key)); var signingCredentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256Signature); var tokenDescriptor = new SecurityTokenDescriptor { Issuer = \u0026#34;發行者\u0026#34;, Subject = claimsIdentity, Expires = DateTime.UtcNow.AddMinutes(30), SigningCredentials = signingCredentials }; var tokenHandler = new JwtSecurityTokenHandler(); var securityToken = tokenHandler.CreateToken(tokenDescriptor); return Ok(tokenHandler.WriteToken(securityToken)); } 呼叫API 取得Token https://localhost:7102/api/Authorize/GetToken?username=JimWang 恭喜 ! 做到這邊就成功發行了 JWT Token ，我們拿去解析下 nbf 代表從這個時間以前無效 exp 有效期限 iat 發行時間 驗證 Token 我們發行了 Token 下一個問題點在於，當使用者拿著 Token 來的時候，我該怎麼驗證這份 Token\n一樣是 Blazor.Jwt.Server 專案內，在Program.cs中加入服務 1 2 3 4 5 6 7 8 9 10 11 12 builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = \u0026#34;http://schemas.xmlsoap.org/ws/2005/05/identity/claims/nameidentifier\u0026#34;, ValidateIssuer = true, ValidIssuer = \u0026#34;發行者\u0026#34;, ValidateLifetime = true, IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(\u0026#34;2022/09/28 IThome 鐵人賽\u0026#34;)) }; }); 這邊的 option 有非常多的設定可以調整，要注意需要填入簽名使用的 key，如果有驗證發行者alidateIssuer = true，也需要填入生產Token時的發行者\n加入驗證服務 1 builder.Services.AddAuthorization(); 最後在下方app的部分加入兩行 1 2 app.UseAuthentication(); app.UseAuthorization(); 注意順序不可以錯誤 先驗證再授權!!!\n套用 JWT 我們完成了發行以及驗證，可是好像還沒有用上，最後一個步驟做整合，讓我們的 WebAPI 受到身分驗證的保護\n回到 AuthorizeController.cs 再加入一個新的 action 1 2 3 4 5 6 [HttpGet] [Authorize] public IActionResult GetUserInfo() { return Ok(\u0026#34;取得使用者資料\u0026#34;); } 呼叫 GetUserInfo() 會發現回覆的 HttpStatusCode 從 200 變成 401，因為我這一個請求沒有帶入Token，所以伺服器直接回覆我 Code 401，接著我們再試著帶入 Token 並且執行\n帶入 Token 呼叫成功 小結 明天我們會在 Blazor WebAssembly 練習取得 Token ，並且請求(Request) 中一起帶入 Token，取得伺服器的資源\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-014-jwtimplement/","summary":"前言 上一章我們介紹了 JWT 的基本原理，接下來我們會建立一個 WebAPI 並透過他發行 JWT Token，然後將導入 Token 驗證的機制 建立 WebAssembly 專案 開啟 Visual Studio 點選建立新專案並點","title":"ASP.NET Core Blazor 系列 - 014 身分驗證 實作JWT"},{"content":"前言 驗證與授權一直是網站一個很重要的部分，Blazor Server 的專案，和以往的 ASP.NET MVC 專案類似，在這邊比較特別的是 Blazor WebAssembly，因為他是一個在使用者端運作的程式，也就代表著使用者端可以任意修改程式碼，所以驗證相較於 Server 專案是沒那麼重要的\n在這一個章節我會在 託管在 .net Core 上的 WebAssembly 實作JWT驗證，由於是 Step by Step 所以這個主題稍微長一些\nJSON Web Tokens (JWT) 簡介 這邊簡單的介紹為什麼用 JWT ，在過去許多的專案中使用的驗證機制是伺服器端建立 Session，但是 Session 並不適合在多台主機部署的情況，因為 Session 是建立在伺服器的記憶體內，可是不同機器間記憶體不能互相溝通，所以想要橫向部署時並不是太方便\n可以理解成 Session 是客人到櫃檯登記，櫃檯會紀錄客人資訊發行一張票卷蓋上章，下次客人再來時拿著票卷，櫃檯比對有沒有這一發出這一張票卷就知道來的人是誰了\n可是今天有兩個櫃檯的時候，我先到 A 櫃檯拿了一張票，下一次走 B 櫃檯時你拿 A 給你的 票， B 櫃檯是認帳的因為他沒有發行著張票卷的資訊\nJWT的做法可以理解成，A 和 B 兩者都講好了發行票卷的方法，並載明日並且說好怎麼驗證票卷，當使用者取到了票後，不論走到 A 和 走到 B 都可以適用\nJWT 非常適合用在前後端分離的網頁，因為 HTTP 本身是無狀態的，所以每一次來其實伺服器都不認識你，只能透過票卷來辨別使用者的身份\n原理 JWT Token 就像是一張票卷，根據 RFC 7519 發行的票卷，可以記載各種各樣的資訊在上面下面是我發行的一份 Jwt Token\n1 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiLlj4Pos73ogIUiLCJuYW1lIjoiSmltIFdhbmciLCJpYXQiOjE1MTYyMzkwMjJ9.vu7fYCUxT5yvuEJTuzZN3W2abrYiAiblQxoVsoZD2lI Token 可以用 . 拆分成三個部分\nHeader 用來記錄 alg(演算法) 以及 Token Type(typ)\n1 2 3 4 { \u0026#34;alg\u0026#34;: \u0026#34;HS256\u0026#34;, \u0026#34;typ\u0026#34;: \u0026#34;JWT\u0026#34; } Payload 乘載資料類型，這邊有一些類型可以在 規格書4.1 參考\n1 2 3 4 5 { \u0026#34;sub\u0026#34;: \u0026#34;參賽者\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;Jim Wang\u0026#34;, \u0026#34;iat\u0026#34;: 1516239022 } Signature 在這邊 IThome 就是我加密的 Key\n1 2 3 4 HMACSHA256( base64UrlEncode(header) + \u0026#34;.\u0026#34; + base64UrlEncode(payload),IThome ) Header 和 Payload 是資料的部分，第三個 Signature 是用來驗證資料用的\n把 Header 和 Payload 做 UrlEncode 後，加上 Key 做雜湊簽名，如果任何一段資料被修改，做完雜湊的結果就會不同導致Token的第三段比對不起來 如果把這邊第二段的9改成8就會導致新的資料算出來的簽名不同 看到這邊會發現 JWT 本身並不會對資料做隱藏的動作，重點在於可以確保資料的不可竄改性，不可以把機密資料放在 Payload 上，任何一個人拿到 Token 都可以對其做解密查看 Payload\n小結 在實作 JWT 時，你的 Private Key 就是驗證正確性以及確保安全性的關鍵，所以千萬要確保有足夠的安全性，下一章會用 .net Core 來發行一個 JTW 並且讓託管的應用程式去驗證發行的 Token\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-013-jwtintroduce/","summary":"前言 驗證與授權一直是網站一個很重要的部分，Blazor Server 的專案，和以往的 ASP.NET MVC 專案類似，在這邊比較特別的是 Blazor WebAssembly，因為他是一","title":"ASP.NET Core Blazor 系列 - 013 身分驗證 JWT概述"},{"content":"前言 WebAPI 的呼叫已經是網站開發者不可或缺的一項基本能力，如果使用 JS 可能用過 XMLHttpRequest 、 Ajax 、fetch 、axios \u0026hellip;\u0026hellip;等方式來呼叫，如今我們使用 Blazor 開發，可以透過 C# 來做 WebAPI 的處理\nBlazor Server 對於 Server 專案，可以透過 HttpClient 的執行個體發出 HttpRequest來做呼叫，那我們要怎麼取得 HttpClient 呢?\n在 .Net Core 2.1 新增了 IHttpClientFactory ，處理了原先 httpClient Socket 的耗盡的問題以及 DNS 變更的問題\n想要知道更多可以從這邊 在 ASP.NET Core 中使用 IHttpClientFactory 在 Program.cs 內註冊 1 builder.Services.AddHttpClient(); 在Page中，加入一個新元件WebApi.razor，要呼叫的API來源我使用公開資料的電影API 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @page \u0026#34;/WebAPI\u0026#34; @using System.Text.Json @inject IHttpClientFactory ClientFactory \u0026lt;h3\u0026gt;WebApi\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; @foreach (var movie in Movies) { \u0026lt;li\u0026gt;@movie.title\u0026lt;/li\u0026gt; } \u0026lt;/ul\u0026gt; @code { private IEnumerable\u0026lt;Movie\u0026gt; Movies = Array.Empty\u0026lt;Movie\u0026gt;(); protected override async Task OnInitializedAsync() { var request = new HttpRequestMessage(HttpMethod.Get, \u0026#34;https://cloud.culture.tw/frontsite/trans/SearchShowAction.do?method=doFindTypeJ\u0026amp;category=8\u0026#34;); var client = ClientFactory.CreateClient(); var response = await client.SendAsync(request); if (response.IsSuccessStatusCode) { await using var responseStream = await response.Content.ReadAsStreamAsync(); Movies = await JsonSerializer.DeserializeAsync\u0026lt;IEnumerable\u0026lt;Movie\u0026gt;\u0026gt;(responseStream); } } public class Movie { public string version { get; set; } public string UID { get; set; } public string title { get; set; } public string category { get; set; } public Showinfo[] showInfo { get; set; } public string showUnit { get; set; } public string discountInfo { get; set; } public string descriptionFilterHtml { get; set; } public string imageUrl { get; set; } public string[] masterUnit { get; set; } public string[] subUnit { get; set; } public object[] supportUnit { get; set; } public string[] otherUnit { get; set; } public string webSales { get; set; } public string sourceWebPromote { get; set; } public string comment { get; set; } public string editModifyDate { get; set; } public string sourceWebName { get; set; } public string startDate { get; set; } public string endDate { get; set; } public int hitRate { get; set; } } public class Showinfo { public string time { get; set; } public string location { get; set; } public string locationName { get; set; } public string onSales { get; set; } public string price { get; set; } public string latitude { get; set; } public string longitude { get; set; } public string endTime { get; set; } } } 在 OnInitializedAsync 上去做API的呼叫\n完成後將程式跑起來就會看到這樣的結果 由於是在後端完成呼叫，所以在開發人員工具上看不到呼叫API的行為 Blazor WebAssembly WebAssembly 的專案預先就加入了 HttpClient 的服務，要注意的是這邊的 HttpClient 是透過 Fetch API 來實作的，和 Server 專案由 C# 實作不同\n一樣我們建立一個 WebApi.razor 元件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 @page \u0026#34;/WebAPI\u0026#34; @using System.Net.Http @using System.Net.Http.Json @using System.Threading.Tasks @inject HttpClient Http \u0026lt;h3\u0026gt;WebApi\u0026lt;/h3\u0026gt; \u0026lt;ul\u0026gt; @foreach (var movie in Movies) { \u0026lt;li\u0026gt;@movie.title\u0026lt;/li\u0026gt; } \u0026lt;/ul\u0026gt; @code { private List\u0026lt;Movie\u0026gt; Movies = new List\u0026lt;Movie\u0026gt;(); protected override async Task OnInitializedAsync() =\u0026gt; Movies = await Http.GetFromJsonAsync\u0026lt;List\u0026lt;Movie\u0026gt;\u0026gt;(\u0026#34;https://cloud.culture.tw/frontsite/trans/SearchShowAction.do?method=doFindTypeJ\u0026amp;category=8\u0026#34;); public class Movie { public string version { get; set; } public string UID { get; set; } public string title { get; set; } public string category { get; set; } public Showinfo[] showInfo { get; set; } public string showUnit { get; set; } public string discountInfo { get; set; } public string descriptionFilterHtml { get; set; } public string imageUrl { get; set; } public string[] masterUnit { get; set; } public string[] subUnit { get; set; } public object[] supportUnit { get; set; } public string[] otherUnit { get; set; } public string webSales { get; set; } public string sourceWebPromote { get; set; } public string comment { get; set; } public string editModifyDate { get; set; } public string sourceWebName { get; set; } public string startDate { get; set; } public string endDate { get; set; } public int hitRate { get; set; } } public class Showinfo { public string time { get; set; } public string location { get; set; } public string locationName { get; set; } public string onSales { get; set; } public string price { get; set; } public string latitude { get; set; } public string longitude { get; set; } public string endTime { get; set; } } } 執行起來，可以發現 Request 是在瀏覽器端執行的 如果不想要用預設的 HttpClient，也可以採用像是 Server 專案的寫法使用IHttpClientFactory\n需要安裝 Netget Microsoft.Extensions.Http，在 razro 元件中原本的 @inject HttpClient Http 改成 @IHttpClientFactory ClientFactory，其餘的可以參照Server專案\n前面有提到在 Wasm 中，呼叫 API 的是用 Fetch 來做的，想要設定 Fatch 的參數也是可以的，可以用 HttpRequestMessage 來做設定\n1 2 3 4 5 6 7 8 9 10 HttpRequestMessage requestMessage = new HttpRequestMessage(); // Fatch cache requestMessage.SetBrowserRequestCache(); // Fatch credentials requestMessage.SetBrowserRequestCredentials(); // Fatch integrity requestMessage.SetBrowserRequestIntegrity(); // Fatch mode requestMessage.SetBrowserRequestMode(); 小結 API的呼叫基本上大同小異，練習後就可以熟練掌握兩種專案呼叫的用法，下一個章節來介紹 Blazor 的身分與驗證\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-012-callwebapi/","summary":"前言 WebAPI 的呼叫已經是網站開發者不可或缺的一項基本能力，如果使用 JS 可能用過 XMLHttpRequest 、 Ajax 、fetch 、axios \u0026hellip;\u0026hellip;等方式來","title":"ASP.NET Core Blazor 系列 - 012 WebAPI 呼叫"},{"content":"前言 在網頁的開發中，上傳檔案是一個非常常見的需求，本章節會介紹在開發 Blazor 時，該怎麼來實現檔案上傳的功能，Server 和 WebAssembly 雖然細節上有些差異但大致上是相通的\n檔案流程 Blazor Server 與後端伺服器的溝通是透過 SignalR 溝通，檔案是透過 SignalR 傳輸到 .NET 上 Blazor WebAssembly 檔案資料會直接串流到 .NET 程式碼上 上傳檔案 (Blazor WebAssembly) 建立一個新的元件，名稱為 FileUpload\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @using System.Net.Http.Headers @inject HttpClient Http @page \u0026#34;/FileUpload\u0026#34; \u0026lt;h3\u0026gt;檔案上傳\u0026lt;/h3\u0026gt; \u0026lt;InputFile OnChange=\u0026#34;@OnInputFileChange\u0026#34; /\u0026gt; @code { private bool shouldRender; protected override bool ShouldRender() =\u0026gt; shouldRender; private async Task OnInputFileChange(InputFileChangeEventArgs e) { using var content = new MultipartFormDataContent(); foreach (var file in e.GetMultipleFiles()) { var fileContent = new StreamContent(file.OpenReadStream(1024 * 1000)); fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType); content.Add(fileContent,\u0026#34;\\\u0026#34;files\\\u0026#34;\u0026#34;,file.Name); } await Http.PostAsync(\u0026#34;api/File\u0026#34;, content); shouldRender = true; } } 其中的 1024 * 100 是我要調整上傳檔案的大小的限制，預設為 500 KB 為了方便講解，沒有對檔案做必要的安全性處理，正式使用時請依照安全性原則處理檔案上傳 相關的資料可以查看官方文件 安全性考量\n這邊建立了一個 type = file的input，並且在檔案變動時，發出Request將檔案串流到至伺服器端\n完成 razor 元件的部分後，我們來處理 API Controller 的內容，建立一個 API 控制器名稱為 FileController，並撰寫內容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 [Route(\u0026#34;api/[controller]\u0026#34;)] [ApiController] public class FileController : ControllerBase { private readonly IWebHostEnvironment _env; public FileController(IWebHostEnvironment env) { _env = env; } [HttpPost] public async Task\u0026lt;IActionResult\u0026gt; PostFile([FromForm] IEnumerable\u0026lt;IFormFile\u0026gt; files) { var filesProcessed = 0; foreach (var file in files) { var path = Path.Combine(_env.ContentRootPath, _env.EnvironmentName, \u0026#34;image\u0026#34;, file.FileName); await using FileStream fs = new(path, FileMode.Create); await file.CopyToAsync(fs); filesProcessed++; } return Ok(); } } 上傳檔案 (Blazor Server) 在 Blazor Server 上的檔案上傳大同小異，只是要在 Program.cs 註冊HttpClient\n1 builder.Services.AddHttpClient(); 並且對剛剛 WebAssembly 的 Componet 做修改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @inject IHttpClientFactory ClientFactory @using System.Net.Http.Headers @page \u0026#34;/FileUpload\u0026#34; \u0026lt;h3\u0026gt;檔案上傳\u0026lt;/h3\u0026gt; \u0026lt;InputFile OnChange=\u0026#34;@OnInputFileChange\u0026#34; /\u0026gt; @code { private bool shouldRender; protected override bool ShouldRender() =\u0026gt; shouldRender; private async Task OnInputFileChange(InputFileChangeEventArgs e) { using var content = new MultipartFormDataContent(); foreach (var file in e.GetMultipleFiles()) { var fileContent = new StreamContent(file.OpenReadStream(1024 * 1000)); fileContent.Headers.ContentType = new MediaTypeHeaderValue(file.ContentType); content.Add(fileContent, \u0026#34;\\\u0026#34;files\\\u0026#34;\u0026#34;, file.Name); } var client = ClientFactory.CreateClient(); await client.PostAsync(\u0026#34;https://localhost:7197/api/File\u0026#34;, content); shouldRender = true; } } 有發現不一樣的地方嗎? @inject HttpClient Http 變成 @inject IHttpClientFactory ClientFactory\n而API的部分是相同的所以可以直接參照上方的 API Controller\n小結 這邊透過簡單的方式去示範檔案上傳的做法，在真實環境中務必注意安全性，以免對資料造成損失，下一章會介紹兩種 Blazor 專案要怎麼呼叫 WebAPI\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-011-file/","summary":"前言 在網頁的開發中，上傳檔案是一個非常常見的需求，本章節會介紹在開發 Blazor 時，該怎麼來實現檔案上傳的功能，Server 和 WebAssembly 雖然細節上有些差異但大","title":"ASP.NET Core Blazor 系列 - 011 檔案處理"},{"content":"前言 在上一篇說明 JS 互通性時，有提到在 Blazor 上撰寫 JS 的部分，現在來介紹在 Blazor 中 CSS 的部分\nCSS Isolation (CSS 隔離) 大家都知道 CSS 的套用是全域的，只要符合 CSS Selector 的所選的項目就會被套用上對應的樣式，想跑都沒辦法跑，為了避免衝突，微軟在 .Net 5 支援了在元件中使用 CSS Isolation，我們來看一下他是怎麼運作的\n首先，我們將目光轉移到 wwwroot/index.html，在其中會看到有引入一個專案名稱.style.css\n可是在專案目錄中卻找不到這份檔案的存在\n這是因為這個檔案是所有的元件CSS，編譯後匯總產生，接下來我們來實作一下CSS，看一下隔離是怎麼實現的\n在Pages資料夾中新增一個檔案，名稱為 Index.razor.css 完成後會發現他躲在Index.razor檔案下，其實這樣做就完成隔離了，在其中寫的CSS只會和Index.razor內的元素產生反應\n在剛剛新增的 Index.razor.css內撰寫內容\n1 2 3 h1{ color: #ff0000; } 執行專案，觀察結果 h1 標籤的 Hello World，成功變色了 打開開發人員工具看一下會發現在 h1 的 html 上多了b-x8jq25t3t1，CSS的選擇器則變成h1[b-x8jq25t3t1] 這個看起來像是亂碼的就是 CSS 隔離實行的關鍵，編譯時會給予隨機的字串，用以區別各個元件內的 CSS Selector\n子元件的 CSS 隔離 演示一下正常的情況 建立一個 CssTest.razor ，將原本的 h3 改成 h1\n1 2 3 4 5 \u0026lt;h1\u0026gt;CssTest\u0026lt;/h1\u0026gt; @code { } 然後放到 Index.razor ˋ 中\n1 2 3 4 5 6 7 8 9 10 @page \u0026#34;/\u0026#34; \u0026lt;PageTitle\u0026gt;Index\u0026lt;/PageTitle\u0026gt; \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt; \u0026lt;CssTest\u0026gt;\u0026lt;/CssTest\u0026gt; Welcome to your new app. \u0026lt;SurveyPrompt Title=\u0026#34;How is Blazor working for you?\u0026#34; /\u0026gt; 可以發現子元件的h1標籤沒有被轉譯過 如果想讓子元件也可以讀取到父元件的 CSS 樣式，只需要加入 ::deep，所以回到剛剛的 Index.razor.css\n1 2 3 ::deep h1{ color: #ff0000; } 完成後執行就會發現 啪! 沒了，怎麼連原本的紅色都沒了??? 導致這樣的原因是 ::deep 被轉譯後變成 b-x8jq25t3t1 所以CSS樣式變成這樣\n1 2 3 [b-x8jq25t3t1] h1{ color: #ff0000; } HTML的部分則是這樣\n1 2 \u0026lt;h1 b-x8jq25t3t1 \u0026gt;Hello, world!\u0026lt;/h1\u0026gt; \u0026lt;h1\u0026gt;CssTest\u0026lt;/h1\u0026gt; 仔細看會發現轉譯後的 CSS Selector 沒有選到我們要套用樣式的元素，應該在外包一層有 x8jq25t3t1 的標籤，所以我們只要在外層包一個div就可以了\nIndex.razor\n1 2 3 4 5 6 7 8 9 10 11 @page \u0026#34;/\u0026#34; \u0026lt;PageTitle\u0026gt;Index\u0026lt;/PageTitle\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Hello, world!\u0026lt;/h1\u0026gt; \u0026lt;CssTest/\u0026gt; \u0026lt;/div\u0026gt; Welcome to your new app. \u0026lt;SurveyPrompt Title=\u0026#34;How is Blazor working for you?\u0026#34; /\u0026gt; 套用後就可以正常使用了! 自訂識別格式 在預設情況，Blazor 框架所產生的CSS隔離識別碼會是b- + 10個字元組成的，如果想要自訂最前面的b也是可以的只需要在專案檔內調整即可\n1 2 3 \u0026lt;ItemGroup\u0026gt; \u0026lt;None Update=\u0026#34;Pages/Component.razor.css\u0026#34; CssScope=\u0026#34;ithome\u0026#34; /\u0026gt; \u0026lt;/ItemGroup\u0026gt; 加入後成果會像是這樣\n如果想要把全部的元件都使用自定義的識別碼，可以把 Component 的名稱改成 *\n前處理器 很多人開發時，會使用 Scss、Less來開發，但是不幸的是 Blazor 的 CSS 隔離目前暫時不支援使用前處理器，但是可以透過一些套件來使用\n關閉 CSS 隔離 如果不想要使用 CSS 隔離，也可以把這項功能關閉，一樣是在專案檔的地方調整\n1 \u0026lt;ScopedCssEnabled\u0026gt;false\u0026lt;/ScopedCssEnabled\u0026gt; 小結 到這邊我們大概清楚了網頁三大要素 HTML、CSS、Javascript 該寫在哪邊，接下來我們來講講在Blazor上檔案的上傳以及下載\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-010-componet-css/","summary":"前言 在上一篇說明 JS 互通性時，有提到在 Blazor 上撰寫 JS 的部分，現在來介紹在 Blazor 中 CSS 的部分 CSS Isolation (CSS 隔離) 大家都知道 CSS 的套用是全域的，只要符合 CSS Selector 的所選的項","title":"ASP.NET Core Blazor 系列 - 010 元件(Componet) CSS"},{"content":"前言 Blazor 應用程式有提供從 JavaSript 呼叫 .NET Method 的方法，當然反過來也可以從 .NET Method 叫用 JavaScript Function，打通兩個語言之間的邊界，讓互動性更上一層樓!\n概觀 在 Blazor 中想要撰寫JS，有五種方式可以挑選\n在 \u0026lt;head\u0026gt; 標記 中載入指令碼 (不推薦) 1 2 3 4 5 6 7 8 \u0026lt;head\u0026gt; \u0026lt;script\u0026gt; window.jsMethod = () =\u0026gt; { alert(\u0026#34;Hello World!\u0026#34;) }; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; 不推薦寫在 head標記內的原因有兩個\n如果指令碼相依於 Blazor，則 JS Interop 可能會失敗 頁面可能會因為解析 JS 所需的時間增加而變慢 在 \u0026lt;body\u0026gt; 標記中載入指令碼 1 2 3 4 5 6 7 8 9 \u0026lt;body\u0026gt; ... \u0026lt;script src=\u0026#34;_framework/blazor.{webassembly|server}.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; window.jsMethod = () =\u0026gt; { alert(\u0026#34;Hello World!\u0026#34;) }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 從外部 JavaScript 檔案載入指令碼 這是最熟悉的方式，獨立的Javascript檔案從外部引入到檔案內，可以將Javascript 放置於wwwroot內 1 2 3 4 5 6 \u0026lt;body\u0026gt; ... \u0026lt;script src=\u0026#34;_framework/blazor.{webassembly|server}.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;{要引入的Javascript檔名.js}\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 從外部 JavaScript 檔案載入指令碼 (.js) 與元件共置 將 JavaScript 檔案組合在一起，以用於頁面(Page)、檢視(View)和 Razor 元件，是組織指令碼的便利方式，在 Blazor 中可以在元件的後方加上.js結尾，看起來像這樣.razor.js Pages/Index.razor.js\n1 2 3 export function showHello() { return prompt(\u0026#39;Hello\u0026#39;); } Pages/Index.razor\n1 2 module = await JS.InvokeAsync\u0026lt;IJSObjectReference\u0026gt;( \u0026#34;import\u0026#34;, \u0026#34;./Pages/Index.razor.js\u0026#34;); 在 Blazor 啟動後插入指令碼 在引入 Blazor 的 JS 時加入屬性 autostart=\u0026quot;false\u0026quot; 在 Blazor.start().then Blazor 啟動後，在建立Sctipt區塊填入JS檔案 1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;body\u0026gt; ... \u0026lt;script src=\u0026#34;_framework/blazor.{webassembly|server}.js\u0026#34; autostart=\u0026#34;false\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; Blazor.start().then(function () { var customScript = document.createElement(\u0026#39;script\u0026#39;); customScript.setAttribute(\u0026#39;src\u0026#39;, \u0026#39;scripts.js\u0026#39;); document.head.appendChild(customScript); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 不要把 \u0026lt;script\u0026gt; 放在 .razor 內，因為 Blazor 無法動態更新\n.NET 叫用 JavaScript 函式 想要在 .Net 內呼叫 JS 方法，首先需要 IJSRuntime 這一個介面，他的實作由 Blazor 框架註冊，這部分介紹兩個方法\nJSRuntimeExtensions.InvokeAsync 這個方法適用於呼叫 JavaScript 函式並讀取傳回的值，用起來的效果像是這樣 JavaScriptRun.razor.js\n1 2 3 export function getHello() { return \u0026#39;Hello\u0026#39;; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 @page \u0026#34;/JsRun\u0026#34; @inject IJSRuntime JS \u0026lt;button @onclick=\u0026#34;getHello\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; \u0026lt;p\u0026gt;@text\u0026lt;/p\u0026gt; @code { private IJSObjectReference? module; protected override async Task OnAfterRenderAsync(bool firstRender) { if (firstRender) { module = await JS.InvokeAsync\u0026lt;IJSObjectReference\u0026gt;(\u0026#34;import\u0026#34;, \u0026#34;./Pages/JavaScriptRun.razor.js\u0026#34;); } } private string text{ get; set; } private async Task getHello() { text = await module.InvokeAsync\u0026lt;string\u0026gt;(\u0026#34;getHello\u0026#34;); } } 這邊採用的是上面的第四種方式: 從外部 JavaScript 檔案載入指令碼 (.js) 與元件共置\nJSRuntimeExtensions.InvokeVoidAsync 這個則是用於呼叫沒有回傳值的 JS 方法 1 2 3 4 5 6 7 8 9 10 11 @page \u0026#34;/JsRun\u0026#34; @inject IJSRuntime JS \u0026lt;button @onclick=\u0026#34;AlertHello\u0026#34;\u0026gt;Click\u0026lt;/button\u0026gt; @code { private async Task AlertHello() { await JS.InvokeVoidAsync(\u0026#34;alert\u0026#34;, \u0026#34;Hello\u0026#34;); } } JS Interop 呼叫預設都是非同步的，如果應用程式只有在 Blazor WebAssembly 執行，可以選擇進行同步 JS Interop 呼叫，這樣會稍微少一些額外負荷，而且可能會縮短轉譯週期\nJavaScript 叫用 .NET 接下來我們說說，從 JS 呼叫 .NET Method的方法\n呼叫靜態方法 DotNet.invokeMethodAsync 這是一個非同步的方法，推薦使用這個來做 .NET 方法的呼叫 語法看起來長這樣 1 DotNet.invokeMethodAsync(\u0026#39;{組件名稱}\u0026#39;, \u0026#39;{方法名稱}\u0026#39;, {參數}); DotNet.invokeMethod 同步方法，僅對 Blazor WebAssembly 應用程式同步 想要讓 JS可以呼叫到 .NET 有幾個先決條件\n方法必須是公開的(Public) 需要加入 [JSInvokable] Attribute JsRun.razor\n1 2 3 4 5 6 7 8 9 10 11 12 13 @page \u0026#34;/JsRun\u0026#34; \u0026lt;button onclick=\u0026#34;getString()\u0026#34;\u0026gt; Click \u0026lt;/button\u0026gt; @code { [JSInvokable] public static async Task\u0026lt;string\u0026gt; GetHello() { await Task.CompletedTask; return \u0026#34;Hello\u0026#34;; } } 仔細看在Button Click的事件，沒有加入 @ 代表這不是 Razor 語法\nJsRun.js\n1 2 3 4 5 6 window.getString = () =\u0026gt; { DotNet.invokeMethodAsync(\u0026#39;BlazorApp1\u0026#39;, \u0026#39;GetHello\u0026#39;) .then(data =\u0026gt; { console.log(data); }); }; 填入組件名稱以及方法名稱，就可以從JS呼叫 .NET 靜態方法了\n執行個體方法 直接上程式碼 JsRun.razor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 @page \u0026#34;/JsRun\u0026#34; @implements IDisposable @inject IJSRuntime JS \u0026lt;button @onclick=\u0026#34;JsCallInstanceMethod\u0026#34;\u0026gt; 按我呼叫C# 執行個體方法 \u0026lt;/button\u0026gt; \u0026lt;P\u0026gt;@result\u0026lt;/P\u0026gt; @code { private string? result; private DotNetObjectReference\u0026lt;JsRun\u0026gt;? objRef; public async Task JsCallInstanceMethod() { objRef = DotNetObjectReference.Create(this); result = await JS.InvokeAsync\u0026lt;string\u0026gt;(\u0026#34;sayHello\u0026#34;, objRef); } [JSInvokable] public string GetHelloMessage() { return $\u0026#34;Hello !\u0026#34;; } public void Dispose() { objRef?.Dispose(); } } JsRun.razor.js\n1 2 3 window.sayHello = (dotNetHelper) =\u0026gt; { return dotNetHelper.invokeMethodAsync(\u0026#39;GetHelloMessage\u0026#39;); }; 呼叫執行個體方法稍稍複雜了一些，我們一步一步看他是怎麼執行的\n首先按鈕按下去後，執行JsCallInstanceMethod()，建立新的 DotNetObjectReference\u0026lt;JsRun\u0026gt; 執行個體 執行 JS 的 sayHello Function，調用 .NET GetHelloMessage 方法，完成後結果回傳給result 最後為了避免記憶體洩漏以及允許GC，DotNetObjectReference 建立的執行個體要被放在 Dispose 內 小結 就這樣我們一來一回的完成兩種語言的相互呼叫，在JS互通其實還有很多好玩的東西和細節，像是可以直接把stream 從 JS 傳輸到 .NET 、Blazor 在 JavaScript Module 有啟用JavaScript 隔離再也不用擔心全域汙染的問題\u0026hellip;\u0026hellip;等等，一時半刻也說不清，在後續的章節慢慢補充說明\n寫完這篇才發現忘記介紹在 Blazor 該怎麼寫 CSS 了XDD 下一篇文章回頭說說 Blazor 元件 CSS\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-009-jsinterop/","summary":"前言 Blazor 應用程式有提供從 JavaSript 呼叫 .NET Method 的方法，當然反過來也可以從 .NET Method 叫用 JavaScript Function，打通兩個語言之間的邊界，讓互動性更上一層樓! 概觀 在 Blazor 中","title":"ASP.NET Core Blazor 系列 - 009 JavaScript 互通性 (JS interop)"},{"content":"前言 這個章節介紹 Blazor 的事件處理，事件的引數、使用方式以及範例\n事件介紹 這是一個非常簡單的按鈕事件範例，點下按鈕後會在Console內輸出 Hello World\n1 2 3 4 5 \u0026lt;button onclick=\u0026#34;myFunction()\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt; function myFunction() { console.log(\u0026#34;Hello World\u0026#34;); } 而在 Blazor 內沒有了JS該怎麼做才能實現一樣的功能呢? 很簡單! 只要將原本的 onclick 改寫成 Razor的語法，再將JavaScript的部分改成C#的Method就可以了，看起來會像是這樣\n1 2 3 4 5 6 7 8 9 \u0026lt;button @onclick=\u0026#34;MyMethod\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt; @code { private void MyMethod() { Console.WriteLine(\u0026#34;Hello World\u0026#34;); } } 比對一下在HTML內的區別，可以看到要將原本的 onclick 改成Razor的方法，只需要在前面加上@並且將後方的JS方法改成C#的方法名稱就可以了\nRazor的語法如下\n1 @on{DOM EVENT}=\u0026#34;{DELEGATE}\u0026#34; DomEvent 是Dom事件的名稱可以從文件看到所有的事件列表 Delegate 是要呼叫的C#方法名稱 在Blazor的事件處理機制中有三個小細節\nC#的方法支援回傳為Task的非同步方法 會自動觸發UI轉譯，不必手動呼叫 StateHasChanged 系統可以攔截例外 事件處理常式支援Lambda 運算式 引數 在使用JS的事件時，有一個事件物件 (Event Object) 裡面包含了所有與這個事件有關的屬性，而如今 Blazor 當然也有類似的物件設計，那就是事件引數\n套用剛剛的範例我們在方法內看起來像這樣\n1 2 3 4 5 6 7 8 9 \u0026lt;button @onclick=\u0026#34;MyMethod\u0026#34;\u0026gt;Click me\u0026lt;/button\u0026gt; @code { private void MyMethod(EventArgs e) { Console.WriteLine(\u0026#34;Hello World\u0026#34;); } } 在 EventArgs 內會紀錄事件相關的屬性，例如位置、類型等等 其他還有很多內建的事件引數例如與滑鼠相關的MouseEventArgs、鍵盤相關的KeyboardEventArgs，如果想看所有的事件可以從這邊查閱\nEventCallback 常見案例會在發生子元件事件時執行父元件的方法，用法類似參數那一篇文章，父子參數傳遞的部分\n子元件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;p\u0026gt; \u0026lt;button @onclick=\u0026#34;OnClickCallback\u0026#34;\u0026gt; 呼叫父元件方法 \u0026lt;/button\u0026gt; \u0026lt;/p\u0026gt; @code { [Parameter] public string? Title { get; set; } [Parameter] public RenderFragment? ChildContent { get; set; } [Parameter] public EventCallback\u0026lt;MouseEventArgs\u0026gt; OnClickCallback { get; set; } } 父元件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;Child Title=\u0026#34;來自父元件的參數\u0026#34; OnClickCallback=\u0026#34;@ShowMessage\u0026#34;\u0026gt; 由父元件提供子元件內容 \u0026lt;/Child\u0026gt; \u0026lt;p\u0026gt;@message\u0026lt;/p\u0026gt; @code { private string? message; private void ShowMessage(MouseEventArgs e) { message = $\u0026#34;Blazor Click事件觸發 ! ({e.ScreenX}:{e.ScreenY})\u0026#34;; } } 小結 經由這一個章節，了解元件事件的處理，如果手邊有相關的Web專案，可以嘗試寫一份Blaor的版本，你將會得到不一樣的開發感受，但在寫的過程中可能發現還是有些情境非使用 JavaScript 不可，那該怎麼辦呢?\n下一個章節我們來講講 JavaScript 互通性\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-008-componet-eventhandling/","summary":"前言 這個章節介紹 Blazor 的事件處理，事件的引數、使用方式以及範例 事件介紹 這是一個非常簡單的按鈕事件範例，點下按鈕後會在Console內輸出 Hello World 1 2","title":"ASP.NET Core Blazor 系列 - 008 元件(Componet) 事件處理"},{"content":"前言 在前幾個章節中，我們實作了一些元件，但是元件我們不知道元件是什麼時候建立的也還不知道什麼時候會消失，今天就來說說元件從建立到銷毀的流程與事件\n流程 Constructor SetParametersAsync OnInitialized \u0026amp; OnInitializedAsync OnParametersSet \u0026amp; OnParametersSetAsync OnAfterRender \u0026amp; OnAfterRenderAsync Dispose 在Blazor元件中Constructor的用途不大，因為目前不支援建構式注入\n建立一個 Lifecycle.razor 來觀察生命週期\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @inject ILogger\u0026lt;Lifecycle\u0026gt; Logger @code { public override async Task SetParametersAsync(ParameterView parameters) { Logger.LogInformation(\u0026#34;SetParametersAsync-開始\u0026#34;); await base.SetParametersAsync(parameters); Logger.LogInformation(\u0026#34;SetParametersAsync-結束\u0026#34;); } protected override void OnInitialized() { Logger.LogInformation(\u0026#34;OnInitialized-開始\u0026#34;); base.OnInitialized(); Logger.LogInformation(\u0026#34;OnInitialized-結束\u0026#34;); } protected override async Task OnInitializedAsync() { Logger.LogInformation(\u0026#34;OnInitializedAsync-開始\u0026#34;); await base.OnInitializedAsync(); Logger.LogInformation(\u0026#34;OnInitializedAsync-結束\u0026#34;); } protected override void OnParametersSet() { Logger.LogInformation(\u0026#34;OnParametersSet-開始\u0026#34;); base.OnParametersSet(); Logger.LogInformation(\u0026#34;OnParametersSet-結束\u0026#34;); } protected override async Task OnParametersSetAsync() { Logger.LogInformation(\u0026#34;OnParametersSetAsync-開始\u0026#34;); await base.OnParametersSetAsync(); Logger.LogInformation(\u0026#34;OnParametersSetAsync-結束\u0026#34;); } protected override void OnAfterRender(bool firstRender) { Logger.LogInformation($\u0026#34;OnAfterRender({firstRender})-開始\u0026#34;); base.OnAfterRender(firstRender); Logger.LogInformation($\u0026#34;OnAfterRender({firstRender})-結束\u0026#34;); } protected override async Task OnAfterRenderAsync(bool firstRender) { Logger.LogInformation($\u0026#34;OnAfterRenderAsync({firstRender})-開始\u0026#34;); await base.OnAfterRenderAsync(firstRender); Logger.LogInformation($\u0026#34;OnAfterRenderAsync({firstRender})-結束\u0026#34;); } public void Dispose() { Logger.LogInformation(\u0026#34;Dispose\u0026#34;); } } OnInitialized \u0026amp; OnInitializedAsync 1 2 protected virtual void OnInitialized (); protected virtual System.Threading.Tasks.Task OnInitializedAsync (); 這是元件初始化的執行的第一個方法\n於元件的 SetParametersAsync 完成後呼叫 首先會呼叫同步的 OnInitialized 然後才呼叫 OnInitializedAsync 資料的載入可以放在這一個步驟處理 所有需要在元件渲染完成後執行重新渲染的非同步行為都應該放在OnInitializedAsync OnInitializedAsync 在預先渲染時會被呼叫兩次 元件以靜態的呈現時 瀏覽器重新渲染時 這邊指的預先渲染是為了SEO所做的處理，因為SPA對搜尋引擎來說是一張白紙，採用預先選染可以處理SEO不佳的問題，關於 Blazor 預先渲染該怎麼做，日後會再寫一篇文章來說明\nOnParametersSet \u0026amp; OnParametersSetAsync 1 2 protected virtual void OnParametersSet (); protected virtual System.Threading.Tasks.Task OnParametersSetAsync (); 在 OnInitialized OnInitializedAsync 之後被呼叫 當父組件重新渲染或者提供新的參數後被呼叫 OnAfterRender \u0026amp; OnAfterRenderAsync 1 2 protected virtual void OnAfterRender (bool firstRender); protected virtual System.Threading.Tasks.Task OnAfterRenderAsync (bool firstRender); 每一次元件重新渲染時呼叫 OnAfterRender 的重要用途是用於 JavaScript 初始化，因為需要DOM元素載入完成 參數的 firstRender 在第一次呼叫時會是 true ，這個參數可以確保初始化只有一次 StateHasChanged 1 protected void StateHasChanged (); 用來通知元件狀態變更 可以手動觸發UI渲染 小結 經過上面的例子，我們可以了解Blazor元件的線性生命週期，但是在真正的現實狀況中，不是那麼的標準，要注意的是非同步方法的呼叫可能會導致生命週期順序紊亂或重疊，例如OnAfterRenderAsync 可能多次被呼叫，而上一次的 OnAfterRenderAsync 尚未執行完成，在使用上需要多注意\n下一個章節是元件的事件處理\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-007-componet-lifecycle/","summary":"前言 在前幾個章節中，我們實作了一些元件，但是元件我們不知道元件是什麼時候建立的也還不知道什麼時候會消失，今天就來說說元件從建立到銷毀的流程與","title":"ASP.NET Core Blazor 系列 - 007 元件(Componet) 生命週期"},{"content":"前言 在第四章元件的介紹中，提到元件可重複使用，但是如果元件的內容都固定了要怎麼重複使用呢?\n寫程式的大家都知道，看到重複的邏輯時應當要抽離成方法(Method)，當一段重複的邏輯要重構成方法時，要做的步驟如下:\n先分析類似的邏輯中哪些部分完全相同，哪些地方有一點不同 完全相同的部分，依樣畫葫蘆 有一點不同的部分，將其中變化的地方外移到參數，由外部傳入 元件也是一樣的，一個可重複使用的元件，可能會有一些地方需要變化，這時候就需要使用到參數來處理，畢竟參數本身就是值的不確定性，今天讓我們一起來認識 Blazor 元件中的參數該如何使用\n參數 [Parameter] 我們以一個簡單的元件範例來做說明，這是Bootstrap Card，有10張這樣的卡片要製作，但是不一樣的地方只有內容，此時我們就可以把這份 Card 做成 Card.razor\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;div class=\u0026#34;card\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;card-header\u0026#34;\u0026gt; @CardHeader \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;card-body\u0026#34;\u0026gt; \u0026lt;blockquote class=\u0026#34;blockquote mb-0\u0026#34;\u0026gt; \u0026lt;p\u0026gt;@Text\u0026lt;/p\u0026gt; \u0026lt;footer class=\u0026#34;blockquote-footer\u0026#34;\u0026gt;@Author\u0026lt;/footer\u0026gt; \u0026lt;/blockquote\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; @code { [Parameter] public string CardHeader{ get; set; } [Parameter] public string Text{ get; set; } [Parameter] public string Author { get; set; } } 在元件中，替公開屬性上加入 Parameter Attribute，就會被識別為參數 完成這個 Card.razor 之後，在另一個元件中可以呼叫它，看起來會像是這樣\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @page \u0026#34;/ParamterSample\u0026#34; \u0026lt;h3\u0026gt;ParamterSample\u0026lt;/h3\u0026gt; \u0026lt;Card CardHeader=\u0026#34;第一則\u0026#34; Text=\u0026#34;寫程式時要保持這種心態：就好像將來要維護你這些程式的人是一位殘暴的精神病患者，而且他知道你住在哪\u0026#34; Author=\u0026#34;Martin Golding\u0026#34;\u0026gt; \u0026lt;/Card\u0026gt; \u0026lt;Card CardHeader=\u0026#34;第二則\u0026#34; Text=\u0026#34;這不是個 bug——這一個未註明的功能特徵\u0026#34; Author=\u0026#34;Anonymous\u0026#34;\u0026gt; \u0026lt;/Card\u0026gt; 在引用其他元件時需注意，元件的參數內容如果需要從C#內指派，要在被指派的成員前面加上@符號\n1 \u0026lt;Card CardHeader=\u0026#34;@Header\u0026#34; Text=\u0026#34;@Text\u0026#34; Author=\u0026#34;@Author\u0026#34;\u0026gt;\u0026lt;/Card\u0026gt; 參數的一點點細節 參數應該要宣告為自動屬性 不應該在參數的存取子內撰寫邏輯，因為是參數的提供給父元件傳值的通道，如果在子元件存取子內有使父元件重新渲染的邏輯，這時候就會產生無窮迴圈 1 2 [Parameter] public string Text{ get; set; } 如果要操作參數的資料，另外做屬性或方法是比較好的做法\n指派內容到元件參數時，不可以執行非同步工作 1 2 3 \u0026lt;Card CardHeader=\u0026#34;@await GetHeader\u0026#34; \u0026lt;/Card\u0026gt; // \u0026#39;await\u0026#39; 運算子只能在非同步方法中使用。 // 請考慮使用 \u0026#39;async\u0026#39; 修飾詞標記這個方法，並將其傳回類型變更為 \u0026#39;Task\u0026#39;。 如果要從非同步的作業中取值，可以使用元件生命週期的OnInitializedAsync，寫起來會像是這樣\n1 2 3 4 5 6 7 8 9 \u0026lt;Card CardHeader=\u0026#34;@title\u0026#34; \u0026lt;/Card\u0026gt; @code{ private string? title; protected override async Task OnInitializedAsync() { title = await GetHeader(); } } 生命週期也會專門做文章跟大家探討\n不支援使用明確 Razor 運算式來串連文字與運算式結果 1 2 \u0026lt;Card CardHeader=\u0026#34;我的卡片 @(Card.Title)\u0026#34; \u0026lt;/Card\u0026gt; // Component attributes do not support complex content (mixed C# and markup). 如果要做字串連接，可以在下方code區域處理字串後在使用\n參數傳遞 父元件(Parent component) -\u0026gt; 子元件(Child component) 父元件 Parent.razor\n1 2 3 4 5 6 7 8 9 10 11 12 @page \u0026#34;/Parent\u0026#34; \u0026lt;h3\u0026gt;父子元件參數傳遞\u0026lt;/h3\u0026gt; \u0026lt;h4\u0026gt;父元件\u0026lt;/h4\u0026gt; \u0026lt;input class=\u0026#34;form-control\u0026#34; @bind=\u0026#34;ParentMessage\u0026#34;\u0026gt; \u0026lt;Child\u0026gt;\u0026lt;/Child\u0026gt; @code { [Parameter] public string ParentMessage{ get; set; } } 子元件 Child.razor\n1 2 3 4 5 6 7 \u0026lt;h4\u0026gt;子元件\u0026lt;/h4\u0026gt; \u0026lt;input value=\u0026#34;@ChildMessage\u0026#34; class=\u0026#34;form-control\u0026#34;\u0026gt; @code { [Parameter] public string ChildMessage{ get; set; } } 打開父元件的頁面是長這樣\n要在對父元件的Input輸入時，將參數傳給子元件，做法如下\n子元件內加入EventCallback\u0026lt;T\u0026gt;，T 是子元件內部接收外部參數的型別並且命名為Changed。 父元件的 ParentMessage 參數，要傳遞到子元件內的 ChildMessage 參數，所以EventCallback 的 \u0026lt;T\u0026gt; 會是ChildMessage的型別也就是string，EventCallback的參數名稱 必須 是子元件參數名稱加上Changed，寫起來會像是這樣 1 2 [Parameter] public EventCallback\u0026lt;string\u0026gt; ChildMessageChanged { get; set; } 父元件中 bind 子元件內的參數即可 1 \u0026lt;Child @bind-ChileMessage=\u0026#34;ParentMessage\u0026#34;\u0026gt;\u0026lt;/Child\u0026gt; 如此就實現父傳子的功能\n如果命名不想要受到 慣例(Convention) 的影響，只要將父元件的 bind 拆開處理即可\n子元件(Child component) -\u0026gt; 父元件(Parent component) 在子元件內加入事件，對 Input 輸入完成後，透過事件去更新子元件的欄位，去呼叫 ChildMessageChanged，這樣的做法被稱為 鏈式綁定(Chained bind)\n1 2 3 4 5 private async Task UpdateMessageFromChild(ChangeEventArgs args) { ChildMessage = args.Value.ToString(); await ChildMessageChanged.InvokeAsync(ChildMessage); } 小結 我們了解了元件該怎麼設定參數，還有非常重要的參數傳遞的方法，下一章介紹元件的一生是怎麼樣過的會，來了解它的生命中會遇到什麼事件\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-006-componet-parameter/","summary":"前言 在第四章元件的介紹中，提到元件可重複使用，但是如果元件的內容都固定了要怎麼重複使用呢? 寫程式的大家都知道，看到重複的邏輯時應當要抽離成方","title":"ASP.NET Core Blazor 系列 - 006 元件(Componet) 參數"},{"content":"前言 上一篇我們做了一個簡單的表單元件，其中有用到 bind-value 來將 input 內的資料轉送到 C# 內，在這一篇我會來介紹 Razor 元件當中資料繫結的細節(繞口令)\nData Binding 我看過有些翻譯翻成 資料繫結 有些則是翻成 資料綁定，我覺得這兩個都很到位，只是繫結這個詞真的很難打 XD\n@bind 請先建立 BindSample.razor 元件\n1 2 3 4 5 6 7 8 9 @page \u0026#34;/Bind\u0026#34; \u0026lt;h3\u0026gt;BindSample\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;輸入的文字是: @Message \u0026lt;/p\u0026gt; \u0026lt;input @bind=\u0026#34;Message\u0026#34; placeholder=\u0026#34;請輸入文字\u0026#34; /\u0026gt; @code { private string Message { get; set; } } 完成後開啟網頁到該元件的Url，並且在紅色的方框內輸入文字，完成後按下Enter後就在上方橘色框顯示輸入的文字\n從 BindSample 的程式碼中可以看見，在input元素內寫了 @bind=\u0026quot;Data\u0026quot; 這會讓下方的Data屬性與input的value做雙向的連結，如果有接觸過Vue的人可能有在Vue的官網看到一篇範例，在input欄位輸入後馬上就會反應在橘色的框框內\n怎麼到了 Blazor 還要多按一下Enter呢？\n會導致這樣的原因請看下方的程式碼\n1 2 3 4 5 // 我們寫的 \u0026lt;input @bind=\u0026#34;Message\u0026#34; placeholder=\u0026#34;請輸入文字\u0026#34; /\u0026gt; // 概念上等於 \u0026lt;input value=\u0026#34;@Message\u0026#34; @onchange=\u0026#34;@((ChangeEventArgs __e) =\u0026gt; Message = __e?.Value?.ToString())\u0026#34; /\u0026gt; @bind 在做綁定時預設的事件是 onchange ，這是需要離開input 或者 需要按下Enter才會有反應的主因，如果希望達成同步的效果只需要變更觸發的事件(oninput)即可\n1 \u0026lt;input @bind-=\u0026#34;Data\u0026#34; @bind:event=\u0026#34;oninput\u0026#34; placeholder=\u0026#34;請輸入文字\u0026#34; /\u0026gt; 如果今天 bind 的型別是 int ，event 觸發的時輸入的值為int不能接受的內容(例如 3.14)，會自動還原成原始值\nMultiple Select 如果你的 Select 允許複選時，C#的屬性需要調整為陣列\n必須為陣列類型，使用其他型別會導致 Exception\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;select @bind=\u0026#34;joinGroup\u0026#34; class=\u0026#34;form-control input-lg\u0026#34; multiple\u0026gt; @foreach (var item in group) { \u0026lt;option value=\u0026#34;@item\u0026#34;\u0026gt;@item\u0026lt;/option\u0026gt; } \u0026lt;/select\u0026gt; @code { private List\u0026lt;string\u0026gt; group = new List\u0026lt;string\u0026gt; { \u0026#34;Agile\u0026#34;,\u0026#34;AI\u0026amp;Data\u0026#34;,\u0026#34;DevOps\u0026#34;,\u0026#34;IT管理\u0026#34;,\u0026#34;Mobile Development\u0026#34;, \u0026#34;Modern Web\u0026#34;,\u0026#34;Security\u0026#34;,\u0026#34;Software Development\u0026#34;,\u0026#34;Web 3\u0026#34;,\u0026#34;影片教學\u0026#34; }; private string[] joinGroup = new string[] { }; } 格式化 日期格式化 先來一段程式碼\n1 2 3 4 5 6 7 \u0026lt;p\u0026gt;日期格式化: @Date \u0026lt;/p\u0026gt; \u0026lt;input @bind=\u0026#34;Date\u0026#34; @bind:format=\u0026#34;yyyy-MM-dd\u0026#34; /\u0026gt; @code { private DateTime Date { get; set; } } 若bind的資料型別是DateTime，可以使用 @bind:format 來做日期格式化，目前只有支援日期格式，日後的版本可能會新增其他格式的支援\n此處的input type是預設的text，如想要改成 type=\u0026quot;date\u0026quot; format 格式必須要是 yyyy-MM-dd 也就說要這樣寫\n1 \u0026lt;input type=\u0026#34;date\u0026#34; @bind:format=\u0026#34;yyyy-MM-dd\u0026#34;\u0026gt; 自訂格式 預設的 bind:format 目前只有支援日期的，但我們可以透過C#的存取子來實作自訂格式處理 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;p\u0026gt;自定格式化: @FormatPrice \u0026lt;/p\u0026gt; \u0026lt;input @bind=\u0026#34;Price\u0026#34; /\u0026gt; @code { private decimal Price; private string FormatPrice { get =\u0026gt; Price.ToString(\u0026#34;C\u0026#34;, CultureInfo.CurrentCulture); } } 小結 這篇文章我們學會了將C#內的物件成員和HTML頁面的資料做繫結、如何做格式化還有繫結的概念。\n關於bind還有幾個重要的用法還沒有說明，分別是元件參數繫結以及跨元件繫結，這兩個牽涉到還沒有碰過的元件參數的部分，我會在明日的章節講解參數的時候一起說明。\n下一篇文章介紹元件參數的使用\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-005-componet-databinding/","summary":"前言 上一篇我們做了一個簡單的表單元件，其中有用到 bind-value 來將 input 內的資料轉送到 C# 內，在這一篇我會來介紹 Razor 元件當中資料繫結的細節(繞口令) Data Binding 我看過有","title":"ASP.NET Core Blazor 系列 - 005 元件(Componet) 資料繫結"},{"content":"前言 元件(Componet) 是 Blazor 應用程式的基礎，是 UI 的元素，例如頁面、按鈕或者是表單，正式名稱為 Razor 元件(Razor component)\nRazor 是一種結合了 HTML 標記語言 與 C# 程式碼的語法\n內建在 .NET 組件中且具有下列功能的 .NET C# 類別：\n處理邏輯來啟用動態行為 可以為巢狀結構，且可重複使用 能以 Razor 類別庫或 NuGet 套件方式共用及散發 元件是由 C# 和 HTML 標記組合，檔案的副檔名為 .razor\n命名 需要以大寫的字母開頭 正確的命名 SampleComponet.razor\n錯誤的命名(編譯無法通過) sampleComponet.razor\n檔案名稱即是元件的名稱 再次以 SampleComponet.razor 為例，此時的元件名稱就會是SampleComponet\n看看 Counter 元件 在 Counter 文件中，我按照內容劃分了四個區塊\n@page 這個指示詞在Blazor中編譯時，會用做提供路由，以 @page \u0026quot;/counter\u0026quot;為例，我們可以透過 http://localhost:5001/counter 這個Url來呼叫Counter元件 更加詳細的路由說明，會在之後的文章為大家講解\nPageTitle 這邊載入 PageTitle 元件，看到這邊可能會有個疑惑\n他是誰? 他在哪? 他從哪裡來?\n為什麼專案沒有看到 PageTitle.razor 檔案卻可以被載入呢? 原因是他是微軟預先定義好的元件放置於 Microsoft.AspNetCore.Components.Web 這個Namespace中，聰明如你一定馬上衍伸另一個問題\n我也沒有 using 呀\n在專案內有個 _Imports.razor 內部會負責引用命名空間，放在其檔案內部的都會被所有元件載入 Razor 語法 這部分是Razor的語法，@currentCount會直接帶入對應的 C# 變數值 @onclick 則是對應 Razor @on{DOM EVENT}=\u0026quot;{DELEGATE}\u0026quot; 對點擊事件做處理 關於Blazor 的事件處理，也會在之後的文章為大家講解\n@code 區塊 在這邊撰寫 C# 邏輯程式碼 Razor 標記 和 C# 程式碼位於相同的檔案中，是元件撰寫中最常見的方法。\n實作表單元件 看到這邊大家應該都會了吧? 我們實作一個鐵人賽的報名頁面\n首先到方案總管內的Pages資料夾，右鍵-\u0026gt;加入-\u0026gt;Razor元件 對元件進行命名， 這邊我將元件取名為 IthomeIronMan.razor 加入 @Page 讓元件可以被呼叫 1 2 3 4 5 6 7 @page \u0026#34;/IthomeIronMan\u0026#34; \u0026lt;h3\u0026gt;IthomeIronMan\u0026lt;/h3\u0026gt; @code { } 做完後可以就可以把專案跑起來，網址輸入剛剛在Page後面加的 /IthomeIronMan 就可以看見剛剛新建立的元件\n接下來補上一點點細節 元件內部使用的語法是 Razor 語法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @page \u0026#34;/IthomeIronMan\u0026#34; @using System.ComponentModel.DataAnnotations \u0026lt;h3\u0026gt;主題競賽報名\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;請選擇組別，並填寫參賽題目及簡介。\u0026lt;/p\u0026gt; \u0026lt;EditForm Model=\u0026#34;@ironmanApplyModel\u0026#34; OnValidSubmit=\u0026#34;@HandleSubmit\u0026#34;\u0026gt; \u0026lt;DataAnnotationsValidator /\u0026gt; \u0026lt;ValidationSummary /\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-title\u0026#34; for=\u0026#34;exampleFormControlSelect1\u0026#34;\u0026gt;選擇主題\u0026lt;/label\u0026gt;\u0026lt;label class=\u0026#34;note\u0026#34;\u0026gt;報名後無法修改\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;form-group \u0026#34;\u0026gt; \u0026lt;InputSelect @bind-Value=\u0026#34;ironmanApplyModel.Group\u0026#34; class=\u0026#34;form-control input-lg\u0026#34; required=\u0026#34;required\u0026#34;\u0026gt; \u0026lt;option value=\u0026#34;\u0026#34; disabled selected=\u0026#34;selected\u0026#34;\u0026gt;請選擇您要參加的競賽主題\u0026lt;/option\u0026gt; @foreach (var item in group) { \u0026lt;option value=\u0026#34;@item\u0026#34;\u0026gt;@item\u0026lt;/option\u0026gt; } \u0026lt;/InputSelect\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-title\u0026#34; for=\u0026#34;topic\u0026#34;\u0026gt;參賽題目\u0026lt;/label\u0026gt; \u0026lt;label class=\u0026#34;note\u0026#34;\u0026gt;開賽前可以修改，80個字以內\u0026lt;/label\u0026gt; \u0026lt;InputText id=\u0026#34;agenda\u0026#34; @bind-Value=\u0026#34;ironmanApplyModel.Topic\u0026#34; class=\u0026#34;form-control\u0026#34; placeholder=\u0026#34;80 個字以內\u0026#34; required=\u0026#34;required\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-title\u0026#34; for=\u0026#34;intro\u0026#34;\u0026gt;題目簡介\u0026lt;/label\u0026gt; \u0026lt;label class=\u0026#34;note\u0026#34;\u0026gt;簡單介紹參賽的內容與方向，300個字以內\u0026lt;/label\u0026gt; \u0026lt;InputTextArea @bind-Value=\u0026#34;ironmanApplyModel.Description\u0026#34; class=\u0026#34;form-control input-lg\u0026#34; cols=\u0026#34;30\u0026#34; rows=\u0026#34;10\u0026#34; maxlength=\u0026#34;300\u0026#34; required=\u0026#34;required\u0026#34;\u0026gt;\u0026lt;/InputTextArea\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;form-group form-check\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; class=\u0026#34;form-check-input\u0026#34; id=\u0026#34;done\u0026#34; required=\u0026#34;required\u0026#34;\u0026gt; \u0026lt;label class=\u0026#34;form-check-label\u0026#34; for=\u0026#34;done\u0026#34;\u0026gt;我已閱讀並同意受本\u0026lt;a href=\u0026#34;https://r.itho.me/ironguide\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;活動簡章\u0026lt;/a\u0026gt;及相關辦法規定之拘束。\u0026lt;/label\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; class=\u0026#34;btn btn-primary btn-lg btn-block\u0026#34;\u0026gt;確定報名\u0026lt;/button\u0026gt; \u0026lt;/EditForm\u0026gt; @code { private List\u0026lt;string\u0026gt; group = new List\u0026lt;string\u0026gt; { \u0026#34;Agile\u0026#34;,\u0026#34;AI\u0026amp;Data\u0026#34;,\u0026#34;DevOps\u0026#34;,\u0026#34;IT管理\u0026#34;,\u0026#34;Mobile Development\u0026#34;, \u0026#34;Modern Web\u0026#34;,\u0026#34;Security\u0026#34;,\u0026#34;Software Development\u0026#34;,\u0026#34;Web 3\u0026#34;,\u0026#34;影片教學\u0026#34; }; private IronmanApplyModel ironmanApplyModel = new IronmanApplyModel(); private void HandleSubmit() { Console.WriteLine($\u0026#34;送出成功! 主題:{ironmanApplyModel.Group} 題目:{ironmanApplyModel.Topic} 說明:{ironmanApplyModel.Description}\u0026#34;); } public class IronmanApplyModel { [Required] public string Group { get; set; } [Required] [StringLength(80)] public string Topic { get; set; } [Required] [StringLength(300)] public string Description { get; set; } } } 填寫完成後送出可以在 Console 內看見送出的內容 將元件加入側邊選單 目前我們的元件有了 @page 指示詞 可以透過Url存取但是沒辦法透過UI的方式進入，最後我們將頁面放到選單中就完成這一個 Lab 了\n在 Shard 資料夾內找到 NavMenu.razor 檔案 在檔案內加入 Navlink 元件 1 2 3 4 5 \u0026lt;div class=\u0026#34;nav-item px-3\u0026#34;\u0026gt; \u0026lt;NavLink class=\u0026#34;nav-link\u0026#34; href=\u0026#34;IthomeIronman\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;oi oi-list-rich\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; 報名鐵人賽 \u0026lt;/NavLink\u0026gt; \u0026lt;/div\u0026gt; 小結 在這一個章節中我們了解了元件的命名規則、建立了一個元件、體驗了用C#來撰寫前端邏輯並且將元件與UI相結合。\n下一個章節會介紹元件的資料繫結(Data Binding)\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-004-componet-overview/","summary":"前言 元件(Componet) 是 Blazor 應用程式的基礎，是 UI 的元素，例如頁面、按鈕或者是表單，正式名稱為 Razor 元件(Razor component) Razor 是一種結合了 HTML 標記語言","title":"ASP.NET Core Blazor 系列 - 004 元件(Componet) 概觀"},{"content":"前言 在這一章會介紹 Blazor WebAssembly，分別是獨立(Standalone) Blazor WebAssembly和裝載(Hosted) Blazor WebAssembly 兩種範本專案。\n環境 Windows 11 Visual Studio 2022 .NET 6.0 Blazor WebAssembly (Standalone) 專案建立與執行 首先開啟 Visual Studio 2022，找到 Blazor WebAssembly 應用程式 在設定完專案名稱和路徑後，在其他資訊的選單可以做選擇是否要裝載在 ASP.NET Core 上(Hosted)，以及是否在啟用PWA的支援 專案建立完成後也是一樣點擊最上方長得像播放按鈕的開始偵錯，讓專案跑起來 建置完成就會又看見熟悉的 Hello World! 但是仔細看會發現一個不一樣的地方 Loading 會發現最一開始比起 Blazor Server 多了 Loading 頁面 Home Counter FetchData 其餘的頁面皆相同\n專案結構(Standalone) 接下來我們將目光移到VS內的方案總管\nBlazor Server 的部分已經分享過了，這次依照兩者的相異之處說明\n1. wwwroot 異動 原有的根頁面 從 _Host.cshtml 被 index.html取代 元件轉譯的位置在\u0026lt;div id=\u0026quot;app\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;的位置 2. Data 移除 原有的邏輯寫入頁面內部 3. Pages 異動 _Host.cshtml 被index.html取代移除 _Layout.cshtml 因為沒有了_Host.cshtml故也不存在，head 內容也轉移至 index.html 4. Properties 特別說明 在launchSettings.json檔案內，會多一行 inspectUrl 屬性，這個屬性的功能有以下兩個 1.讓 IDE 偵測應用程式是否為 Blazor WebAssembly 應用程式 2.指示腳本偵錯基礎結構透過 Blazor 的偵錯 Proxy 連線到瀏覽器 6. Other 剩下的是沒有在資料夾內的檔案\nappsetting.json 此檔案不再wasm範本中 Program.cs 設定 WebAssembly 主機的應用程式進入點，可以設定根元件以及要渲染的標籤 Blazor WebAssembly (Hosted) 專案 專案建立與執行 步驟大致上相同，只需在建立專案時，額外勾選裝載在ASP.NET Core上即可 在方案總管中會有兩個 Web 的專案，請啟動 Server 的專案，Client不需要啟動 當初我以為要啟動兩個專案，在設定啟動專案的視窗把兩個Web專案都勾選啟動 這樣做會看到 Socket Exception 告訴你Port被佔用了 專案結構(Hosted) 預設的專案範本有建立了三個專案，Client、Server、Shared\n1. Client 與上面的 Standalone 差不多，在 FetchData 元件內部有稍微不同\nStandalone FetchData.razor 1 2 3 4 protected override async Task OnInitializedAsync() { forecasts = await Http.GetFromJsonAsync\u0026lt;WeatherForecast[]\u0026gt;(\u0026#34;sample-data/weather.json\u0026#34;); } Hosted FetchData.razor 1 2 3 4 protected override async Task OnInitializedAsync() { forecasts = await Http.GetFromJsonAsync\u0026lt;WeatherForecast[]\u0026gt;(\u0026#34;WeatherForecast\u0026#34;); } GetFromJsonAsync 的方法參數不同\n2. Server 看是一個 ASP.NET Core 的 Web 專案\n專案內沒有 wwwroot 資料夾 Program.cs 的內容稍微與平常看到的不一樣 1 2 app.UseBlazorFrameworkFiles(); app.MapFallbackToFile(\u0026#34;index.html\u0026#34;); 3. Shared 是用來存放共用類別的地方\n運作方式 Blazor WebAssembly 是透過 WebAssembly 在瀏覽器端執行 .NET 程式碼，在網頁開啟時將會載入相關的 .NET 組件，其中包含相對應的 RunTime\n在Console中看見負責處理的檔案是blazor.webassembly.js\nBlazor Server，UI需要透過SignalR來與伺服端通訊和更新，在Blazor WebAssembly則不需要，所以比較不會有延遲的問題產生\n小結 Blazor Webassembly 本質上是一系列的檔案以及Javascript檔案，所以只要檔案可以正確地被載入並且瀏覽器支援WebAssembly，網頁就可以運作，所以 Blazor WebAssembly App 不必是 ASP.NET Core 網站，他可以是純HTML，甚至透過CDN來部署\n這邊總結一下我認為什麼時候選擇 獨立(Standalone) 什麼時候選擇 裝載(Hosted)\n若是你在開發Blazor WebAssembly App 的同時，使用 ASP.NET Core 撰寫後端，則可以使用同一個網站來做部署，這種情況可以直接使用裝載(Hosted)進行開發 ；如果你已有現有的第三方API或是 .NET Framework 既有的 Web API，可以直接使用獨立(Standalone) Blazor WebAssembly 開發\nBlazer WebAssembly 可以開發成完全不需要外部服務的應用程式，但可能為了安全性會想額外寫一個外部應用程式開放API，用來讀取資料庫、進行使用者驗證等等行為。\n專案範本的裝載(Hosted) 在 ASP.NET Core 上是指透過 ASP.NET Core 來開發外部應用程式(念起來很繞口)\n優點 載入完成後可以離線使用 運算負載會轉移到客戶端 缺點 瀏覽器需要支援 WebAssembly，需注意瀏覽器 載入時間會依應用程式複雜度增加而增加 ","permalink":"https://twjimwang.github.io/posts/programming/blazor-003-blazorwebassembly-projectstructure/","summary":"前言 在這一章會介紹 Blazor WebAssembly，分別是獨立(Standalone) Blazor WebAssembly和裝載(Hosted) Blazor WebAssembly 兩種範本專案","title":"ASP.NET Core Blazor 系列 - 003 專案架構(Blazor WebAssembly)"},{"content":"前言 在接下來的章節將會對兩種 Bloazr 的專案範本做解說，分別是 Blazor Server 以及 Blazor WebAssembly，其中 WebAssembly 會介紹獨立(Standalone) Blazor WebAssembly 和裝載(Hosted) Blazor WebAssembly。\n環境 Windows 11 Visual Studio 2022 .NET 6.0 Blazor Server 專案建立 首先開啟 Visual Studio 2022，找到 Blazor Server 應用程式 專案建立完成後點擊最上方長得像播放按鈕的開始偵錯，就可以進行編譯讓專案跑起來 在 .Net 6 預設是使用 Kestrel 啟動，而不是過去的 IIS\n建置完成就會看見熟悉的 Hello World! Home Counter FetchData 專案結構 接下來我們將目光移到VS內的方案總管\n這邊分成五大區塊來做說明\n1. Properties 在這個資料夾內有 LaunchSettings.json 檔案，用來提供VS執行應用程式時所要套用的組態設定 2. wwwroot 用來放靜態資產檔案的資料夾 3. Data 可以看見內部有兩個檔案\nWeatherForecast.cs 提供FetchData元件的資料類別 1 2 3 4 5 6 7 8 9 10 public class WeatherForecast { public DateTime Date { get; set; } public int TemperatureC { get; set; } public int TemperatureF =\u0026gt; 32 + (int)(TemperatureC / 0.5556); public string? Summary { get; set; } } WeatherForecastService.cs 提供FetchData元件Fetch資料的實作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class WeatherForecastService { private static readonly string[] Summaries = new[] { \u0026#34;Freezing\u0026#34;, \u0026#34;Bracing\u0026#34;, \u0026#34;Chilly\u0026#34;, \u0026#34;Cool\u0026#34;, \u0026#34;Mild\u0026#34;, \u0026#34;Warm\u0026#34;, \u0026#34;Balmy\u0026#34;, \u0026#34;Hot\u0026#34;, \u0026#34;Sweltering\u0026#34;, \u0026#34;Scorching\u0026#34; }; public Task\u0026lt;WeatherForecast[]\u0026gt; GetForecastAsync(DateTime startDate) { return Task.FromResult(Enumerable.Range(1, 5).Select(index =\u0026gt; new WeatherForecast { Date = startDate.AddDays(index), TemperatureC = Random.Shared.Next(-20, 55), Summary = Summaries[Random.Shared.Next(Summaries.Length)] }).ToArray()); } } } 4. Pages 用來放置可供路由的元件或頁面(.razor)\n_Host.cshtml 是Blazor的根頁面(Root Page)，App 元件會解析在這邊 _Layout.cshtml 是 _Host.cshtml 的版面配置頁，Blazor Server 的 head 內容此檔案內 Counter 元件，實作計數器頁面 Error 元件，實作例外頁面 FetchData 元件，實作資料擷取頁 Index 元件，實作首頁 5. Shard 放置共用元件和樣式\nMainLayout 元件，應用程式的版面配置元件 NavMenu 元件，Navbar的樣式表單 SurveyPrompt 元件，問卷元件 6. Other 剩下的是沒有在資料夾內的檔案\n_Imports 元件，內部會放要放入元件內的指示詞，像是 @using App 元件，應用程式的根元件 appsetting.json 專案的設定檔 Program.cs .net Core 應用程式的進入點，在這邊做DI註冊、Middleware的處理等等 運作方式 Blazor Server 是依靠 SignalR 機制讓伺服端與客戶端進行雙向溝通，在瀏覽器開啟 Blazor 網頁時，客戶端會自動與伺服端建立SignalR連線。\n在Console中看見負責處理SignalR的檔案是blazor.server.js\n雙方透過每隔一段時間就會透過心跳包(Heartbeat)機制確保連線\n當我切換到Counter頁面，並且點擊Click Me按鈕觸發 UI 更新時，會重新轉譯元件圖形，計算UI Diff(差異) 後以二進位的方式傳送至瀏覽器套用進行畫面的更新\n透過SignalR的連線處理 JavaScript Interop 呼叫\n從 JavaScript 呼叫 .NET(BeginInvokeDotNetFromJs) 發送事件到伺服端 從 .NET 呼叫 JavaScript (JS.RenderBatch) 伺服端回應進行畫面渲染 從 JavaScript 呼叫 .NET(OnRenderCompleted) 通知伺服端畫面渲染完成 從 .NET 呼叫 JavaScript (JS.EndInvokeDotNet) 完成非同步呼叫 關於 JavaScript Interop 我以後也會專門寫文章跟大家探討XD\n小結 理解了 Blazor Server 運作的原理後，可以總結出幾項優缺點\n優點 載入的速度快 程式碼不會被傳送到Client端，安全性較佳 瀏覽器的支援性較佳 完整的 .NET API 缺點 所有的UI互動都通過與伺服器交互，可能會導致延遲感較明顯 無法使用無伺服器(Serverless)部署 伺服器的記憶體在高負載時可能會是最早耗盡的，一個SignalR線路大概使用250KB的記憶體 根據微軟提供的基準，如果要提供5000名使用者，記憶體至少需要預留1.3GB以上\n下一篇文章介紹 Blazor WebAssembly 的專案建置\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-002-blazorserver-projectstructure/","summary":"前言 在接下來的章節將會對兩種 Bloazr 的專案範本做解說，分別是 Blazor Server 以及 Blazor WebAssembly，其中 WebAssembly 會介紹獨立(Standalone) Blazor WebAssembly 和裝載(","title":"ASP.NET Core Blazor 系列 - 002 專案架構(Blazor Server)"},{"content":"前言 這個系列是記錄我學習 Blazor 的筆記，如果有任何錯誤的地方歡迎提出指教\nBlazor 是微軟打造的新一代全端解決方案，其名稱來自 Browser + Razor 可以讓網頁程式開發拋開 JavaScript 擁抱 C# 享受 .Net 所有的好處\n強型別 使用 C# 取代 Javascript 可以利用 .NET 現有的程式庫 Razor? Blazor? 首先先來整理一些概念，Razor 本身是一個將 .NET 程式碼內嵌到網頁的一種標記語法。\n在 Visual Studio 內建的專案範本，ASP.NET Core MVC 以及 ASP.NET Core Razor Page，在這兩種範本中都會出現Razor的字眼，Razor View 以及 Razor Page，這兩種範本是以 Razor 標記語言 為基底打造的頁面，檔案的副檔名是 .cshtml，其內部使用的語言都是 Razor 標記語言，而Blazor與上述Razor View 和Razor Page 類似屬於一種專案範本，檔案內使用的語言也是 Razor 標記語言，檔案的副檔名是 .razor\n既然 Razor View、Razor Page 以及 Blazor 都是用 Razor 撰寫那他們的差異在哪裡呢?\n最大的不同在於他們轉譯的行為，在 Razor View 以及 Razor Page 時，每一行的Razor程式碼都會被翻譯成HTML送到瀏覽器呈現，轉譯完成後就會執行 Dispose 清除該頁面或者檢視的執行個體以及他們的狀態，當另一個請求發起的時候在重新轉譯並且發送至客戶端，可以理解成每一次的 Request 都會取得全新的頁面。\nBlazor 的做法則是會先產生元件圖形(graph of components)，顯示類似於 HTML 或 XML 文件物件模型 (DOM)。Blazor 在透過元件圖形生成二進位表示法，在客戶端進行轉譯，每一個元件都是獨立的如果有變更就渲染對應的元件即可。\n簡單來說 Razor Page、Razor View 每一個請求都要整個頁面重新載入，而Blazor則可以做到類似JS操作DOM的效果\nBlazor 專案類型 Blazor 有兩種模式可以選擇，一個是 Blazor Server 另一個是 Blazor WebAssembly\nBlazor Server 過去我們在做傳統的網頁時，若希望用MVC做的頁面不會換頁時，會採用 Ajax 的方式來處理，透過WebAPI 取得資料後再利用JS更新畫面UI\nBlazor Server 的做法有異曲同工之妙，將原本的 Ajax 與 WebAPI 的這一段改成 SignalR 來處理， 透過 SignalR 來實作雙向的溝通更新UI。\n在伺服端上處理項目\n執行應用程式的 C# 將瀏覽器的UI 事件傳送到Server 將 UI 更新套用至已轉譯的元件，該元件會由伺服器傳回 在用戶端上，會由 blazor.server.js 建立與伺服器的SignalR連線\n優點 相較於Blazor WebAssembly體積更小載入更快 可以使用完整的伺服器資源 可以套用 .NET 工具，例如偵錯 支援度較高，可在不支援 WebAssembly 和資源限制裝置上的瀏覽器使用 應用程式的程式碼基底不會提供給客戶端 缺點 延遲可能會比較高，因為互動都要透過SignalR傳輸 無法離線使用 使用者人數多的時候需要較多伺服器資源 需要伺服器才能提供應用程式 Blazor WebAssembly Blazor Wasm 的做法更是新穎，透過 WebAssembly (wasm) 直接在瀏覽器執行 .Net 程式碼， 將 .Net RunTime 與 Code 一併打包發送到客戶端執行。\n在客戶端執行的項目\nC# 以及 Razor 被編譯成 .Net 組件 組件以及RunTime被下載到客戶端中 Blazor WebAssembly 啟動 .NET 執行階段，載入應用程式的組件。會使用 JavaScript Interop 來處理 DOM 操作和瀏覽器 API 呼叫 Blazor WebAssembly建立應用程式來部署時，不需要後端 ASP.NET Core應用程式來提供其檔案，則應用程式稱為 獨立(standalone) Blazor WebAssembly 應用程式。\n建立應用程式以使用後端應用程式來提供其檔案的部署時，應用程式稱為 裝載(Hosted) Blazor WebAssembly 的應用程式，會獲得 .NET 的完整堆疊 Web 開發體驗，包括能夠共用用戶端與伺服器應用程式之間的程式碼、支援預先呈現，以及與 MVC 和 Razor Pages 整合。\n在其用戶端應用程式可以使用各種傳訊架構和通訊協定，透過網路與其後端伺服器應用程式互動，例如Web API、gRPC-Web和 SignalR\n以上兩種部屬的模式，皆可以建置為漸進式 Web 應用程式的應用程式 (PWA)，使用新式瀏覽器 API 來啟用原生用戶端應用程式的許多功能，例如離線、在自己的應用程式視窗中執行、從主機的作業系統啟動、接收推播通知，以及在背景自動更新。\nblazor.webassembly.js 是由架構提供，並處理\n下載 .NET Runtime、應用程式和相依性 初始化Runtime 以執行 App 優點 如果伺服器離線，應用程式仍會運作，因為整個 RunTime 都在客戶端 完全運用用戶端資源和功能 運算會從伺服器轉移至用戶端處理 伺服器不需要裝載應用程式。透過內容傳遞網路提供應用程式 (CDN) 可以實現無伺服器的部屬 缺點 應用程式僅限於瀏覽器的功能 需要用戶端硬體和軟體支援，例如 WebAssembly 下載大小較大，而且應用程式需要較長的時間才能載入 如果發布的應用程式大太會導致下載時間較長，會導致使用者體驗不佳。 在這個問題上 Blazor WebAssembly 有幾套機制對大小進行最佳化，以縮短下載時間\n小結 Blazor Server 和 Blazor WebAssembly有各自的優缺點，在評估專案使用的技術時須依照需求進行考量，例如是否會需要完整的 .Net API 、是否需要將運算負載轉移到客戶端、是否需要離線時網頁依然可以保持運作等等，選擇最適合你的 Blazor 運作模式。\n下一篇文章將會介紹 Blazor Server 專案架構\n","permalink":"https://twjimwang.github.io/posts/programming/blazor-001-overview/","summary":"前言 這個系列是記錄我學習 Blazor 的筆記，如果有任何錯誤的地方歡迎提出指教 Blazor 是微軟打造的新一代全端解決方案，其名稱來自 Browser + Razor 可以讓網頁程式開發拋開 JavaScript","title":"ASP.NET Core Blazor 系列 - 001 初次見面"}]